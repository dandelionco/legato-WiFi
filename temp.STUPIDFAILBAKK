diff --git a/KConfig b/KConfig
new file mode 100644
index 0000000..e46326c
--- /dev/null
+++ b/KConfig
@@ -0,0 +1,35 @@
+#
+# Configuration for Legato WiFi module.
+#
+# Copyright (C) Sierra Wireless Inc.
+#
+
+### Options ###
+
+config ENABLE_WIFI
+  bool "Enable WiFi"
+  default y if TARGET_WP750X
+  default y if TARGET_WP85
+  default y if TARGET_WP76XX
+  default y if TARGET_WP77XX
+  default n
+  ---help---
+  Enable Legato WiFi support.
+
+choice
+  prompt "Wifi Platform Adaptor"
+  depends on ENABLE_WIFI
+  default WIFI_PA_TI
+
+config WIFI_PA_TI
+  bool "TI"
+  ---help---
+  Platform adaptor for TI wireless module, such as that on the mangOH WiFi IoT
+  card.
+
+config WIFI_PA_TI_SIMU
+  bool "TI simulator"
+  ---help---
+  Platform adaptor running a simulated TI Access Point.
+
+endchoice # end "WiFi Platform Adaptor"
diff --git a/apps/sample/wifiClientTest/wifiClientTestComponent/Component.cdef b/apps/sample/wifiClientTest/wifiClientTestComponent/Component.cdef
index 834c33f..ebed8bb 100644
--- a/apps/sample/wifiClientTest/wifiClientTestComponent/Component.cdef
+++ b/apps/sample/wifiClientTest/wifiClientTestComponent/Component.cdef
@@ -8,5 +8,6 @@ requires:
     api:
     {
         ${LEGATO_ROOT}/interfaces/wifi/le_wifiClient.api
+        ${LEGATO_ROOT}/interfaces/le_cfg.api
     }
 }
diff --git a/apps/sample/wifiClientTest/wifiClientTestComponent/wifiClientTest.c b/apps/sample/wifiClientTest/wifiClientTestComponent/wifiClientTest.c
index 6142f3f..2b7714f 100644
--- a/apps/sample/wifiClientTest/wifiClientTestComponent/wifiClientTest.c
+++ b/apps/sample/wifiClientTest/wifiClientTestComponent/wifiClientTest.c
@@ -18,6 +18,7 @@
 
 #define NBR_OF_SCAN_LOOPS   2
 #define NBR_OF_PINGS        "5"
+#define TEMP_STRING_MAX_BYTES 512
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -26,6 +27,12 @@
 //--------------------------------------------------------------------------------------------------
 static le_wifiClient_NewEventHandlerRef_t HdlrRef = NULL;
 //--------------------------------------------------------------------------------------------------
+/**
+ * Event indicator handler reference.
+ */
+//--------------------------------------------------------------------------------------------------
+static le_wifiClient_ConnectionEventHandlerRef_t IndHdlrRef = NULL;
+//--------------------------------------------------------------------------------------------------
 /**
  * Access point reference.
  */
@@ -38,6 +45,12 @@ static le_wifiClient_AccessPointRef_t AccessPointRefToConnectTo = NULL;
 //--------------------------------------------------------------------------------------------------
 static uint32_t ScanDoneEventCounter = 0;
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Wifi interface name
+ */
+//--------------------------------------------------------------------------------------------------
+static char   InterfaceName[LE_WIFIDEFS_MAX_IFNAME_BYTES] = {0};
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -50,15 +63,17 @@ static void AskForIpAddress
 )
 {
     int  systemResult;
-    char tmpString[512];
+    char tmpString[TEMP_STRING_MAX_BYTES];
 
     // DHCP client
+    memset(tmpString, '\0', TEMP_STRING_MAX_BYTES);
+
     snprintf(tmpString,
-        sizeof(tmpString),
-        "PATH=/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin;"
-        "/sbin/udhcpc -R -b -i wlan0"
-   );
+            sizeof(tmpString),
+            "PATH=/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin;"
+            "/sbin/udhcpc -R -b -i %s", InterfaceName);
 
+    tmpString[TEMP_STRING_MAX_BYTES - 1] = '\0';
     systemResult = system(tmpString);
     // Return value of -1 means that the fork() has failed (see man system).
     if (0 == WEXITSTATUS(systemResult))
@@ -83,11 +98,12 @@ static void TestToPingGooglesDNS
 )
 {
     int  systemResult;
-    char tmpString[512];
+    char tmpString[TEMP_STRING_MAX_BYTES];
 
     // PING
+    memset(tmpString, '\0', TEMP_STRING_MAX_BYTES);
     snprintf(tmpString, sizeof(tmpString), "ping -c " NBR_OF_PINGS " 8.8.8.8");
-
+    tmpString[TEMP_STRING_MAX_BYTES - 1] = '\0';
     LE_INFO("pinging 8.8.8.8 5x times: %s", tmpString);
     systemResult = system(tmpString);
     // Return value of -1 means that the fork() has failed (see man system).
@@ -188,9 +204,77 @@ static void TestConnect
     }
     else
     {
-        LE_ERROR("AccessPointRefToConnectTo  ERROR: AccessPointRefToConnectTo not found.");
+        LE_ERROR("ERROR: AccessPointRefToConnectTo not found.");
+    }
+}
+//--------------------------------------------------------------------------------------------------
+/**
+ * Handler for WiFi client event indicator changes
+ */
+//--------------------------------------------------------------------------------------------------
+static void WifiClientEventIndHandler
+(
+    const le_wifiClient_EventInd_t* wifiEventPtr,  ///< [IN] Wifi event
+    void* contextPtr                ///< [IN] Associated context pointer
+)
+{
+    LE_DEBUG("WiFi client event: %d, interface: %s, bssid: %s",
+             wifiEventPtr->event,
+             wifiEventPtr->ifName,
+             wifiEventPtr->apBssid);
+
+    switch(wifiEventPtr->event)
+    {
+        case LE_WIFICLIENT_EVENT_CONNECTED:
+        {
+            // WiFi Client Connected
+            LE_DEBUG("LE_WIFICLIENT_EVENT_CONNECTED");
+
+            strncpy(InterfaceName, wifiEventPtr->ifName, LE_WIFIDEFS_MAX_IFNAME_LENGTH);
+            InterfaceName[LE_WIFIDEFS_MAX_IFNAME_LENGTH] = '\0';
+
+            AskForIpAddress();
+
+            TestToPingGooglesDNS();
+
+        }
+        break;
+
+        case LE_WIFICLIENT_EVENT_DISCONNECTED:
+        {
+            // WiFi client Disconnected
+            LE_DEBUG("LE_WIFICLIENT_EVENT_DISCONNECTED");
+            LE_DEBUG("disconnectCause: %d", wifiEventPtr->disconnectionCause);
+            memset(InterfaceName, '\0', LE_WIFIDEFS_MAX_IFNAME_BYTES);
+        }
+        break;
+
+        case LE_WIFICLIENT_EVENT_SCAN_DONE:
+        {
+            ScanDoneEventCounter++;
+            LE_DEBUG("LE_WIFICLIENT_EVENT_SCAN_DONE: "
+                "Now read the results (ScanDoneEventCounter %d)",
+                ScanDoneEventCounter);
+            TestReadScanResults();
+            if (ScanDoneEventCounter < NBR_OF_SCAN_LOOPS)
+            {
+                sleep(2);
+                LE_DEBUG("LE_WIFICLIENT_EVENT_SCAN_DONE: Start New Scan %d)", ScanDoneEventCounter);
+                le_wifiClient_Scan();
+            }
+            else
+            {
+                LE_DEBUG("LE_WIFICLIENT_EVENT_SCAN_DONE: try connect. %d)", ScanDoneEventCounter);
+                TestConnect();
+            }
+        }
+        break;
+        default:
+            LE_ERROR("ERROR Unknown event %d", wifiEventPtr->event);
+        break;
     }
 }
+
 //--------------------------------------------------------------------------------------------------
 /**
  * Handler for WiFi client changes
@@ -212,7 +296,7 @@ static void WifiClientEventHandler
     {
         case LE_WIFICLIENT_EVENT_CONNECTED:
         {
-            ///< WiFi Client Connected
+            // WiFi Client Connected
             LE_DEBUG("LE_WIFICLIENT_EVENT_CONNECTED");
 
             AskForIpAddress();
@@ -224,7 +308,7 @@ static void WifiClientEventHandler
 
         case LE_WIFICLIENT_EVENT_DISCONNECTED:
         {
-            ///< WiFi client Disconnected
+            // WiFi client Disconnected
             LE_DEBUG("LE_WIFICLIENT_EVENT_DISCONNECTED");
         }
         break;
@@ -256,7 +340,6 @@ static void WifiClientEventHandler
 }
 
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * Test: WiFi client
@@ -267,15 +350,24 @@ void Testle_wifiClient
     void
 )
 {
+    le_result_t result;
+
     LE_DEBUG("Start Test");
 
-    // Add an handler function to handle message reception
+    // Add WiFi client event indicator handler
+    IndHdlrRef = le_wifiClient_AddConnectionEventHandler(WifiClientEventIndHandler, NULL);
+    // Add WiFi client event handler (will be deprecated)
     HdlrRef = le_wifiClient_AddNewEventHandler(WifiClientEventHandler, NULL);
 
-    if (LE_OK == le_wifiClient_Start())
+    result = le_wifiClient_Start();
+    if (LE_OK == result)
     {
         LE_DEBUG("Start OK");
     }
+    else if (LE_BUSY == result)
+    {
+        LE_DEBUG("Already started");
+    }
     else
     {
         LE_ERROR("Start ERROR");
@@ -298,6 +390,162 @@ void Testle_wifiClient
 }
 
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Test: WiFi client config loading for a given SSID
+ */
+//--------------------------------------------------------------------------------------------------
+static void Testle_wifiClient_LoadSsid
+(
+    void
+)
+{
+    const uint8_t ssid[] = "Example";
+    const uint8_t username[] = "myName";
+    const uint8_t secret[] = "mySecret";
+    le_result_t ret;
+    le_wifiClient_AccessPointRef_t ref;
+
+    // Test le_wifiClient_LoadSsid() with WEP
+    LE_INFO("Test Wifi's config setting & loading of WEP");
+    ret = le_wifiClient_ConfigureWep(ssid, sizeof(ssid), secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WEP into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WEP; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA passphrase
+    LE_INFO("Test Wifi's config setting & loading of WPA passphrase");
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL,
+                                     secret, sizeof(secret), NULL, 0);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA passphrase into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA passphrase; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA2 PSK
+    LE_INFO("Test Wifi's config setting & loading of WPA2 PSK");
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL,
+                                     NULL, 0, secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA2 PSK into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA2 PSK; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA EAP
+    LE_INFO("Test Wifi's config setting & loading of WPA EAP");
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid),
+                                     LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE,
+                                     username, sizeof(username), secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA EAP into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA EAP; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA2 EAP
+    LE_INFO("Test Wifi's config setting & loading of WPA2 EAP");
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid),
+                                     LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE,
+                                     username, sizeof(username), secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA2 EAP into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA2 EAP; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with no security
+    LE_INFO("Test Wifi's config setting & loading of no security");
+    ret = le_wifiClient_RemoveSsidSecurityConfigs(ssid, sizeof(ssid));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure no security; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over no security; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+}
+
+
 //--------------------------------------------------------------------------------------------------
 /**
  * App init.
@@ -306,6 +554,7 @@ void Testle_wifiClient
 COMPONENT_INIT
 {
     // WiFi Init
-    LE_DEBUG("======== WiFi Client Test  ========");
+    LE_DEBUG("======== WiFi Client Tests  ========");
     Testle_wifiClient();
+    Testle_wifiClient_LoadSsid();
 }
diff --git a/apps/sample/wifiWebAp/wifiWebApComponent/wifiWebAp.c b/apps/sample/wifiWebAp/wifiWebApComponent/wifiWebAp.c
index 131a49d..44fd57f 100644
--- a/apps/sample/wifiWebAp/wifiWebApComponent/wifiWebAp.c
+++ b/apps/sample/wifiWebAp/wifiWebApComponent/wifiWebAp.c
@@ -96,8 +96,8 @@ static void WifiEventHandler
 )
 {
     char   str[BUF_SIZE];
-    char   buffer[BUF_SIZE];
-    time_t timestamp        = time(NULL);
+    char   timebuf[sizeof("HH:MM:SS")];
+    time_t timestamp = time(NULL);
     struct tm tmp = {0};
 
     LE_INFO("WiFi Ap event received");
@@ -115,7 +115,7 @@ static void WifiEventHandler
         LE_ERROR("Cannot convert Absolute time into local time.");
     }
 
-    strftime(buffer, sizeof(buffer), "%H:%M:%S", &tmp);
+    strftime(timebuf, sizeof(timebuf), "%H:%M:%S", &tmp);
 
     switch (event)
     {
@@ -125,7 +125,7 @@ static void WifiEventHandler
             if (LogFilePipePtr != NULL)
             {
                 ///< A client connect to AP
-                snprintf(str, BUF_SIZE, HTTP_CONNECTION_REPORT, buffer, NumberClients);
+                snprintf(str, BUF_SIZE, HTTP_CONNECTION_REPORT, timebuf, NumberClients);
                 LE_INFO("%s", str);
                 WifiEventLog(str, LogFilePipePtr);
             }
@@ -143,7 +143,7 @@ static void WifiEventHandler
             }
             if (LogFilePipePtr != NULL)
             {
-                snprintf(str, BUF_SIZE, HTTP_CONNECTION_REPORT, buffer, NumberClients);
+                snprintf(str, BUF_SIZE, HTTP_CONNECTION_REPORT, timebuf, NumberClients);
                 LE_INFO("%s", str);
                 WifiEventLog(str, LogFilePipePtr);
             }
@@ -228,8 +228,8 @@ static void StartWebServer
 
     if (LogFilePipePtr != NULL)
     {
-        char   buffer[BUF_SIZE];
-        time_t timestamp        = time(NULL);
+        char   timebuf[sizeof("HH:MM:SS")];
+        time_t timestamp = time(NULL);
 
         LE_INFO("STARTING WIFI HTTP INTERFACE");
 
@@ -238,11 +238,11 @@ static void StartWebServer
             LE_ERROR("Cannot convert Absolute time into local time.");
         }
 
-        strftime(buffer, sizeof(buffer), "%H:%M:%S", &tmp);
+        strftime(timebuf, sizeof(timebuf), "%H:%M:%S", &tmp);
         snprintf(str,
             BUF_SIZE,
             "<font color=\"black\" >%s:</font> Starting WiFi HTTP interface...</br>\r\n",
-            buffer);
+            timebuf);
         WifiEventLog(str, LogFilePipePtr);
         fclose(LogFilePipePtr);
     }
diff --git a/apps/test/CMakeLists.txt b/apps/test/CMakeLists.txt
new file mode 100644
index 0000000..113f366
--- /dev/null
+++ b/apps/test/CMakeLists.txt
@@ -0,0 +1,22 @@
+#*******************************************************************************
+# Copyright (C) Sierra Wireless Inc.
+#*******************************************************************************
+
+# Tests
+enable_testing()
+
+# Output
+set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/tests/bin)
+set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/tests/lib)
+set(APP_OUTPUT_PATH ${CMAKE_BINARY_DIR}/tests/apps)
+set(DATA_OUTPUT_PATH ${CMAKE_BINARY_DIR}/tests/data)
+
+file(MAKE_DIRECTORY ${EXECUTABLE_OUTPUT_PATH})
+file(MAKE_DIRECTORY ${LIBRARY_OUTPUT_PATH})
+file(MAKE_DIRECTORY ${APP_OUTPUT_PATH})
+
+# wifi client unitary test
+add_subdirectory(wifiClientUnitTest)
+
+# wifi ap unitary test
+# add_subdirectory(wifiApUnitTest)
diff --git a/apps/test/wifiClientUnitTest/CMakeLists.txt b/apps/test/wifiClientUnitTest/CMakeLists.txt
new file mode 100644
index 0000000..8015678
--- /dev/null
+++ b/apps/test/wifiClientUnitTest/CMakeLists.txt
@@ -0,0 +1,30 @@
+#*******************************************************************************
+# Copyright (C) Sierra Wireless Inc.
+#*******************************************************************************
+
+set(TEST_EXEC wifiClientUnitTest)
+
+set(LEGATO_WIFI_SERVICES "${LEGATO_ROOT}/modules/WiFi/service")
+
+if(TEST_COVERAGE EQUAL 1)
+    set(CFLAGS "--cflags=\"--coverage\"")
+    set(LFLAGS "--ldflags=\"--coverage\"")
+endif()
+
+mkexe(${TEST_EXEC}
+    .
+    -i ${LEGATO_WIFI_SERVICES}/daemon
+    -i ${LEGATO_WIFI_SERVICES}/platformAdaptor/inc
+    -i ${LEGATO_ROOT}/framework/liblegato
+    -i ${PA_DIR}/simu/components/le_pa
+    -i ${PA_DIR}/simu/components/simuConfig
+    -s ${PA_DIR}
+    --cflags="-DWITHOUT_SIMUCONFIG"
+    ${CFLAGS}
+    ${LFLAGS}
+)
+
+add_test(${TEST_EXEC} ${EXECUTABLE_OUTPUT_PATH}/${TEST_EXEC})
+
+# This is a C test
+add_dependencies(tests_c ${TEST_EXEC})
\ No newline at end of file
diff --git a/apps/test/wifiClientUnitTest/Component.cdef b/apps/test/wifiClientUnitTest/Component.cdef
new file mode 100644
index 0000000..12c7bcb
--- /dev/null
+++ b/apps/test/wifiClientUnitTest/Component.cdef
@@ -0,0 +1,22 @@
+requires:
+{
+    api:
+    {
+        ${LEGATO_ROOT}/interfaces/le_cfg.api
+        ${LEGATO_ROOT}/interfaces/wifi/le_wifiClient.api [types-only]
+        ${LEGATO_ROOT}/interfaces/le_secStore.api [types-only]
+    }
+}
+
+sources:
+{
+    main.c
+    stubs.c
+    ${LEGATO_ROOT}/modules/WiFi/service/daemon/le_wifiClient.c
+}
+
+cflags:
+{
+    -Dle_msg_AddServiceCloseHandler=MyAddServiceCloseHandler
+    -I${LEGATO_ROOT}/components/watchdogChain
+}
diff --git a/apps/test/wifiClientUnitTest/interfaces.h b/apps/test/wifiClientUnitTest/interfaces.h
new file mode 100644
index 0000000..f437a2b
--- /dev/null
+++ b/apps/test/wifiClientUnitTest/interfaces.h
@@ -0,0 +1,47 @@
+/**
+ * This module contains function prototype for sim and mrc services.
+ *
+ * Copyright (C) Sierra Wireless Inc.
+ *
+ */
+
+#include "le_wifiClient_interface.h"
+#include "le_cfg_interface.h"
+#include "le_secStore_interface.h"
+
+#undef LE_KILL_CLIENT
+#define LE_KILL_CLIENT LE_WARN
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get the client session reference for the current message (STUBBED FUNCTION)
+ */
+//--------------------------------------------------------------------------------------------------
+le_msg_SessionRef_t le_wifiClient_GetClientSessionRef
+(
+    void
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get the server service reference (STUBBED FUNCTION)
+ */
+//--------------------------------------------------------------------------------------------------
+le_msg_ServiceRef_t le_wifiClient_GetServiceRef
+(
+    void
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Registers a function to be called whenever one of this service's sessions is closed by
+ * the client.  (STUBBED FUNCTION)
+
+ */
+//--------------------------------------------------------------------------------------------------
+le_msg_SessionEventHandlerRef_t MyAddServiceCloseHandler
+(
+    le_msg_ServiceRef_t             serviceRef, ///< [IN] Reference to the service.
+    le_msg_SessionEventHandler_t    handlerFunc,///< [IN] Handler function.
+    void*                           contextPtr  ///< [IN] Opaque pointer value to pass to handler.
+);
diff --git a/apps/test/wifiClientUnitTest/main.c b/apps/test/wifiClientUnitTest/main.c
new file mode 100644
index 0000000..c4bb52f
--- /dev/null
+++ b/apps/test/wifiClientUnitTest/main.c
@@ -0,0 +1,452 @@
+/**
+ * This module implements the unit tests for WiFi client API
+ *
+ * Copyright (C) Sierra Wireless Inc.
+ *
+ */
+
+#include "legato.h"
+#include "interfaces.h"
+#include "wifiService.h"
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Start and stop the WiFi device
+ *
+ * API tested:
+ * - le_wifiClient_Start
+ * - le_wifiClient_Stop
+ */
+//--------------------------------------------------------------------------------------------------
+static void TestWifiClient_StartStop
+(
+    void
+)
+{
+    int i=0;
+    int nbRetries = 10;
+
+    for (i=0; i<nbRetries; i++)
+    {
+        if (i == 0)
+        {
+            // First time, we expect an LE_OK
+            LE_ASSERT(LE_OK == le_wifiClient_Start());
+        }
+        else
+        {
+            LE_ASSERT(LE_BUSY == le_wifiClient_Start());
+        }
+    }
+
+    for (i=0; i<nbRetries; i++)
+    {
+        LE_ASSERT(LE_OK == le_wifiClient_Stop());
+    }
+
+    LE_ASSERT(LE_DUPLICATE == le_wifiClient_Stop());
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Create and destroy a WiFi client reference
+ *
+ * API tested:
+ * - le_wifiClient_Create
+ * - le_wifiClient_Delete
+ * - le_wifiClient_GetSsid
+ */
+//--------------------------------------------------------------------------------------------------
+static void TestWifiClient_CreateDestroy
+(
+    void
+)
+{
+    const uint8_t ssid[] = "Example_of_ssid";
+    size_t ssidNumElements = sizeof(ssid);
+    le_wifiClient_AccessPointRef_t ref;
+
+    LE_ASSERT(NULL == le_wifiClient_Create(NULL, 0));
+    LE_ASSERT(NULL == le_wifiClient_Create(NULL, ssidNumElements));
+
+    ref = le_wifiClient_Create(ssid, ssidNumElements);
+    LE_ASSERT(NULL != ref);
+
+    // Check that if the SSID already exists, the same reference is returned
+    LE_ASSERT(ref == le_wifiClient_Create(ssid, ssidNumElements));
+
+    // Get the SSID given its reference
+    uint8_t getSsid[LE_WIFIDEFS_MAX_SSID_BYTES];
+    size_t  getSsidLen = 1;
+
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_GetSsid(NULL, getSsid, &getSsidLen));
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_GetSsid(ref, NULL, &getSsidLen));
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_GetSsid(ref, getSsid, NULL));
+    LE_ASSERT(LE_OVERFLOW == le_wifiClient_GetSsid(ref, getSsid, &getSsidLen));
+
+    getSsidLen = sizeof(getSsid);
+    LE_ASSERT(LE_OK == le_wifiClient_GetSsid(ref, getSsid, &getSsidLen));
+    LE_ASSERT(0 == memcmp(ssid, getSsid,  getSsidLen));
+    LE_ASSERT(ssidNumElements == getSsidLen);
+
+    // Delete the reference
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_Delete(NULL));
+    LE_ASSERT(LE_OK == le_wifiClient_Delete(ref));
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Connect and disconnect from a WiFi AP
+ *
+ * API tested:
+ * - le_wifiClient_Create
+ * - le_wifiClient_Connect
+ * - le_wifiClient_Disconnect
+ */
+//--------------------------------------------------------------------------------------------------
+static void TestWifiClient_ConnectDisconnect
+(
+    void
+)
+{
+    const uint8_t ssid[] = "Example";
+    size_t ssidNumElements = sizeof(ssid);
+    le_wifiClient_AccessPointRef_t ref;
+
+    ref = le_wifiClient_Create(ssid, ssidNumElements);
+    LE_ASSERT(NULL != ref);
+
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_Connect(NULL));
+    LE_ASSERT(LE_OK == le_wifiClient_Connect(ref));
+
+    LE_ASSERT(LE_OK == le_wifiClient_Disconnect());
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Configure a WIFI client reference
+ *
+ * API tested:
+ * - le_wifiClient_Connect
+ * - le_wifiClient_Disconnect
+ */
+//--------------------------------------------------------------------------------------------------
+static void TestWifiClient_Configure
+(
+    void
+)
+{
+    const uint8_t ssid[] = "Example";
+    size_t ssidNumElements = sizeof(ssid);
+    le_wifiClient_AccessPointRef_t ref;
+
+    ref = le_wifiClient_Create(ssid, ssidNumElements);
+    LE_ASSERT(NULL != ref);
+
+    // Setting a security protocol
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetSecurityProtocol(NULL, 0));
+    LE_ASSERT(LE_OK == le_wifiClient_SetSecurityProtocol(ref, LE_WIFICLIENT_SECURITY_NONE));
+    LE_ASSERT(LE_OK == le_wifiClient_SetSecurityProtocol(ref, LE_WIFICLIENT_SECURITY_WEP));
+    LE_ASSERT(LE_OK ==
+        le_wifiClient_SetSecurityProtocol(ref, LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL));
+    LE_ASSERT(LE_OK ==
+        le_wifiClient_SetSecurityProtocol(ref, LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL));
+    LE_ASSERT(LE_OK ==
+        le_wifiClient_SetSecurityProtocol(ref, LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE));
+    LE_ASSERT(LE_OK ==
+     le_wifiClient_SetSecurityProtocol(ref, LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE));
+
+    // Setting a Passphrase
+    char passBuffer[LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH+1] = {0};
+
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetPassphrase(NULL, passBuffer));
+
+    memset(passBuffer, 0, sizeof(passBuffer));
+    memset(passBuffer, 'A', LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH);
+    LE_ASSERT(LE_OK == le_wifiClient_SetPassphrase(ref, passBuffer));
+
+    memset(passBuffer, 0, sizeof(passBuffer));
+    memset(passBuffer, 'B', LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH-1);
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetPassphrase(ref, passBuffer));
+
+    memset(passBuffer, 0, sizeof(passBuffer));
+    memset(passBuffer, 'C', LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH);
+    LE_ASSERT(LE_OK == le_wifiClient_SetPassphrase(ref, passBuffer));
+
+    memset(passBuffer, 0, sizeof(passBuffer));
+    memset(passBuffer, 'D', LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH+1);
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetPassphrase(ref, passBuffer));
+
+    // Setting PSK key
+    char psk[LE_WIFIDEFS_MAX_PSK_LENGTH] = {0};
+
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetPreSharedKey(NULL, psk));
+    LE_ASSERT(LE_OK == le_wifiClient_SetPreSharedKey(ref, psk));
+
+    // Setting a WEP key
+    char wep[LE_WIFIDEFS_MAX_WEPKEY_BYTES] = {0};
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetWepKey(NULL, wep));
+    LE_ASSERT(LE_OK == le_wifiClient_SetWepKey(ref, wep));
+
+
+    // Setting the hidden attribute
+    LE_ASSERT(LE_BAD_PARAMETER == le_wifiClient_SetHiddenNetworkAttribute(NULL, false));
+    LE_ASSERT(LE_OK == le_wifiClient_SetHiddenNetworkAttribute(ref, false));
+    LE_ASSERT(LE_OK == le_wifiClient_SetHiddenNetworkAttribute(ref, true));
+
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Positive tests of Wifi security config setting & loading of a given SSID
+ *
+ * API tested:
+ * - le_wifiClient_LoadSsid
+ * - le_wifiClient_ConfigureWep
+ * - le_wifiClient_ConfigurePsk
+ * - le_wifiClient_ConfigureEap
+ * - le_wifiClient_RemoveSsidSecurityConfigs
+ */
+//--------------------------------------------------------------------------------------------------
+static void TestWifiClient_LoadSsid
+(
+    void
+)
+{
+    const uint8_t ssid[] = "Example";
+    const uint8_t username[] = "myName";
+    const uint8_t secret[] = "mySecret";
+    le_result_t ret;
+    le_wifiClient_AccessPointRef_t ref;
+
+    // Test le_wifiClient_LoadSsid() with WEP
+    LE_INFO("Test Wifi's config setting & loading of WEP");
+    ret = le_wifiClient_ConfigureWep(ssid, sizeof(ssid), secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WEP into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WEP; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA passphrase
+    LE_INFO("Test Wifi's config setting & loading of WPA passphrase");
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL,
+                                     secret, sizeof(secret), NULL, 0);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA passphrase into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA passphrase; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA2 PSK
+    LE_INFO("Test Wifi's config setting & loading of WPA2 PSK");
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL,
+                                     NULL, 0, secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA2 PSK into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA2 PSK; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA EAP
+    LE_INFO("Test Wifi's config setting & loading of WPA EAP");
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid),
+                                     LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE,
+                                     username, sizeof(username), secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA EAP into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA EAP; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with WPA2 EAP
+    LE_INFO("Test Wifi's config setting & loading of WPA2 EAP");
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid),
+                                     LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE,
+                                     username, sizeof(username), secret, sizeof(secret));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure WPA2 EAP into secStore; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over WPA2 EAP; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+
+    // Test le_wifiClient_LoadSsid() with no security
+    LE_INFO("Test Wifi's config setting & loading of no security");
+    ret = le_wifiClient_RemoveSsidSecurityConfigs(ssid, sizeof(ssid));
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to configure no security; retcode %d", ret);
+    }
+    else
+    {
+        ret = le_wifiClient_LoadSsid(ssid, sizeof(ssid), &ref);
+        if (ret != LE_OK)
+        {
+            LE_ERROR("LoadSsid failed over no security; retcode %d", ret);
+        }
+        else
+        {
+            le_wifiClient_Delete(ref);
+            ref = NULL;
+        }
+    }
+    LE_ASSERT(ret == LE_OK);
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Negative tests of config of Wifi security protocols
+ *
+ * APIs tested:
+ * - le_wifiClient_ConfigureWep
+ * - le_wifiClient_ConfigurePsk
+ * - le_wifiClient_ConfigureEap
+ * - le_wifiClient_RemoveSsidSecurityConfigs
+ */
+//--------------------------------------------------------------------------------------------------
+static void TestWifiClient_ConfigureSecurity_NegTests
+(
+    void
+)
+{
+    const uint8_t ssid[] = "Example";
+    const uint8_t username[] = "myName";
+    const uint8_t secret[] = "mySecret";
+    le_result_t ret;
+
+    // -ve test le_wifiClient_ConfigureWep() with WEP
+    LE_INFO("Negative test Wifi's config setting of WEP");
+    ret = le_wifiClient_ConfigureWep(ssid, sizeof(ssid), NULL, sizeof(secret));
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+
+    // -ve test le_wifiClient_ConfigurePsk() with WPA passphrase
+    LE_INFO("Negative test Wifi's config setting of WPA passphrase");
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WEP,
+                                     secret, sizeof(secret), NULL, 0);
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL,
+                                     NULL, 0, NULL, 0);
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL,
+                                     secret, 1000, NULL, 0);
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+    ret = le_wifiClient_ConfigurePsk(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL,
+                                     NULL, 0, secret, 1000);
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+
+    // -ve test le_wifiClient_ConfigureEap() with EAP
+    LE_INFO("Negative test Wifi's config setting of EAP");
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WEP,
+                                     username, sizeof(username), secret, sizeof(secret));
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid),
+                                     LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE,
+                                     NULL, 0, secret, sizeof(secret));
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+    ret = le_wifiClient_ConfigureEap(ssid, sizeof(ssid), LE_WIFICLIENT_SECURITY_WEP,
+                                     username, sizeof(username), NULL, 0);
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+
+    // -ve test le_wifiClient_RemoveSsidSecurityConfigs() with no security
+    LE_INFO("Negative test Wifi's config setting of no security");
+    ret = le_wifiClient_RemoveSsidSecurityConfigs(ssid, 0);
+    LE_ASSERT(ret == LE_BAD_PARAMETER);
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * main of the test
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+COMPONENT_INIT
+{
+    le_wifiClient_Init();
+
+    LE_INFO ("======== Start UnitTest of WiFi client ========");
+
+    TestWifiClient_StartStop();
+
+    TestWifiClient_CreateDestroy();
+
+    TestWifiClient_ConnectDisconnect();
+
+    TestWifiClient_Configure();
+
+    TestWifiClient_LoadSsid();
+
+    TestWifiClient_ConfigureSecurity_NegTests();
+
+    LE_INFO ("======== UnitTest of WiFi client SUCCESS ========");
+
+    exit(EXIT_SUCCESS);
+}
diff --git a/apps/test/wifiClientUnitTest/stubs.c b/apps/test/wifiClientUnitTest/stubs.c
new file mode 100644
index 0000000..b32bfcf
--- /dev/null
+++ b/apps/test/wifiClientUnitTest/stubs.c
@@ -0,0 +1,559 @@
+/**
+ * @file stubs.c
+ *
+ * Stub functions required for WiFi client unit test
+ *
+ * Copyright (C) Sierra Wireless Inc.
+ */
+
+#include "legato.h"
+#include "interfaces.h"
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Event handler for PA WiFi access point changes.
+ *
+ * Handles the PA WiFi events.
+ */
+//--------------------------------------------------------------------------------------------------
+typedef void (*pa_wifiClient_NewEventHandlerFunc_t)
+(
+    le_wifiClient_Event_t event,
+        ///< [IN]
+        ///< WiFi event to process
+    void *contextPtr
+        ///< [IN]
+        ///< Associated WiFi event context
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Event handler for PA WiFi connection changes.
+ *
+ * Handles the PA WiFi events.
+ */
+//--------------------------------------------------------------------------------------------------
+typedef void (*pa_wifiClient_EventIndHandlerFunc_t)
+(
+    le_wifiClient_EventInd_t* wifiEventIndPtr,
+        ///< [IN]
+        ///< WiFi event pointer to process
+    void *contextPtr
+        ///< [IN]
+        ///< Associated WiFi event context
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * AccessPoint structure.
+ */
+//--------------------------------------------------------------------------------------------------
+typedef struct
+{
+    int16_t  signalStrength;                        ///< LE_WIFICLIENT_NO_SIGNAL_STRENGTH means
+                                                    ///< value was not found.
+    uint8_t  ssidLength;                            ///< The number of bytes in the ssidBytes.
+    uint8_t  ssidBytes[LE_WIFIDEFS_MAX_SSID_BYTES]; ///< Contains ssidLength number of bytes.
+    char     bssid[LE_WIFIDEFS_MAX_BSSID_BYTES];    ///< Contains the bssid.
+} pa_wifiClient_AccessPoint_t;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Struct to hold the AccessPoint from the Scan's data.
+ *
+ */
+//-------------------------------------------------------------------------------------------------
+typedef struct
+{
+    pa_wifiClient_AccessPoint_t accessPoint;
+    bool                        foundInLatestScan;
+}
+FoundAccessPoint_t;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function must be called to initialize the PA WiFi Module.
+ *
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_Init
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Start WiFi Client PA
+ *
+ * @return LE_FAULT  The function failed.
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_Start
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Stop WiFi Client PA
+ *
+ * @return LE_FAULT  The function failed.
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_Stop
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function connects a wifiClient.
+ *
+ * @return LE_FAULT  The function failed.
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_Connect
+(
+    uint8_t ssidBytes[LE_WIFIDEFS_MAX_SSID_BYTES],
+        ///< [IN]
+        ///< Contains ssidLength number of bytes
+    uint8_t ssidLength
+        ///< [IN]
+        ///< The number of Bytes in the ssidBytes
+)
+{
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function disconnects a wifiClient.
+ *
+ * @return LE_FAULT  The function failed.
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_Disconnect
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Clears all username, password, PreShared Key, passphrase settings previously made by
+ *
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_ClearAllCredentials
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set the security protocol for communication.
+ *
+ * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
+ * @return LE_OK             The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_SetSecurityProtocol
+(
+    const le_wifiClient_SecurityProtocol_t securityProtocol
+        ///< [IN]
+        ///< Security protocol used for communication.
+)
+{
+    le_result_t result = LE_BAD_PARAMETER;
+
+    switch (securityProtocol)
+    {
+        case LE_WIFICLIENT_SECURITY_NONE:
+        case LE_WIFICLIENT_SECURITY_WEP:
+        case LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL:
+        case LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL:
+        case LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE:
+        case LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE:
+            result = LE_OK;
+            break;
+
+        default:
+            result = LE_BAD_PARAMETER;
+            break;
+    }
+
+    return result;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set the PassPhrase used to create PSK (WPA-Personal).
+ *
+ * @see  pa_wifiClient_SetPreSharedKey
+ *
+ * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
+ * @return LE_OK             The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_SetPassphrase
+(
+    const char *passphrasePtr
+        ///< [IN]
+        ///< Passphrase used for authentication
+)
+{
+    uint32_t length;
+    // Store Passphrase to be used later during connection procedure
+    le_result_t result = LE_BAD_PARAMETER;
+
+    LE_INFO("Set passphrase");
+    if (NULL != passphrasePtr)
+    {
+        length = strlen(passphrasePtr);
+
+        LE_INFO("Set passphrase");
+        if ((LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH <= length) &&
+            (length <= LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH))
+        {
+           result = LE_OK;
+        }
+        else
+        {
+            LE_ERROR("Invalid passphrase length (%d) [%d..%d]",
+                length,
+                LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH,
+                LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH);
+        }
+    }
+    return result;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set the WiFi pre-shared key (WPA-Personal)
+ *
+ * @see  pa_wifiClient_SetPassPhrase
+ *
+ * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
+ * @return LE_OK             The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_SetPreSharedKey
+(
+    const char *preSharedKeyPtr
+        ///< [IN]
+        ///< Pre-shared key (PSK) used for authentication
+)
+{
+    le_result_t result = LE_BAD_PARAMETER;
+
+    LE_INFO("Set PSK");
+    if (NULL != preSharedKeyPtr)
+    {
+       result = LE_OK;
+    }
+
+    return result;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function specifies whether the target Access Point is hiding its presence from clients or
+ * not. When an Access Point is hidden, it cannot be discovered by a scan process.
+ *
+ * @note By default, this attribute is not set which means that the client is unable to connect to
+ * a hidden access point. When enabled, the client will be able to connect to the access point
+ * whether it is hidden or not.
+ */
+//--------------------------------------------------------------------------------------------------
+void pa_wifiClient_SetHiddenNetworkAttribute
+(
+    bool hidden
+        ///< [IN]
+        ///< If TRUE, the WIFI client will be able to connect to a hidden access point.
+)
+{
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function must be called after the pa_wifiClient_Scan() has been done.
+ * It signals that the scan results are no longer needed and frees some internal resources.
+ *
+ * @return LE_OK     The function succeeded.
+ * @return LE_FAULT  The scan failed.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_ScanDone
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function will start a scan and returns when it is done.
+ * It should NOT return until the scan is done.
+ * Results are read via pa_wifiClient_GetScanResult.
+ * When the reading is done pa_wifiClient_ScanDone MUST be called.
+ *
+ * @return LE_FAULT  The function failed.
+ * @return LE_BUSY   The function is already ongoing.
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_Scan
+(
+    void
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function can be called after pa_wifi_Scan.
+ * When the reading is done, it no longer returns LE_OK,
+ * pa_wifiClient_ScanDone MUST be called.
+ *
+ * @return LE_NOT_FOUND  There is no more AP:s found.
+ * @return LE_OK     The function succeeded.
+ * @return LE_FAULT  The function failed.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_GetScanResult
+(
+    pa_wifiClient_AccessPoint_t *accessPointPtr
+    ///< [IN][OUT]
+    ///< Structure provided by calling function.
+    ///< Results filled out if result was LE_OK.
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set the WEP key (Wired Equivalent Privacy)
+ *
+ * @note WEP is unsecure and has been deprecated by the WiFi alliance. Still, it can be used in
+ * user mode.
+ *
+ * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
+ * @return LE_OK             The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_SetWepKey
+(
+    const char *wepKeyPtr
+        ///< [IN]
+        ///< Wired Equivalent Privacy (WEP) key used for authentication
+)
+{
+    le_result_t result = LE_BAD_PARAMETER;
+
+    if (NULL != wepKeyPtr)
+    {
+       result = LE_OK;
+    }
+    return result;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set the username and password (WPA-Entreprise).
+ *
+ * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
+ * @return LE_OK             The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_SetUserCredentials
+(
+    const char *usernamePtr,
+        ///< [IN]
+        ///< Username used for authentication
+    const char *passwordPtr
+        ///< [IN]
+        ///< Password used for authentication
+)
+{
+    // Store User Credentials to be used later during connection procedure
+    le_result_t result = LE_BAD_PARAMETER;
+
+    LE_INFO("Set user credentials");
+    if (NULL != usernamePtr)
+    {
+       result = LE_OK;
+    }
+    else
+    {
+        return LE_BAD_PARAMETER;
+    }
+
+    if (NULL != passwordPtr)
+    {
+       result = LE_OK;
+    }
+    else
+    {
+        return LE_BAD_PARAMETER;
+    }
+    return result;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Add handler function for PA EVENT 'le_wifiClient_Event_t'
+ *
+ * This event provides information on PA WiFi Client event changes.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_AddEventHandler
+(
+    pa_wifiClient_NewEventHandlerFunc_t handlerPtr,
+        ///< [IN]
+        ///< Event handler function pointer.
+    void *contextPtr
+        ///< [IN]
+        ///< Associated event context.
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Add handler function for PA EVENT 'le_wifiClient_EventInd_t'
+ *
+ * This event provides information on PA WiFi Client event changes.
+ */
+//--------------------------------------------------------------------------------------------------
+LE_SHARED le_result_t pa_wifiClient_AddEventIndHandler
+(
+    pa_wifiClient_EventIndHandlerFunc_t handlerPtr,
+        ///< [IN]
+        ///< Event handler function pointer.
+    void *contextPtr
+        ///< [IN]
+        ///< Associated event context.
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get the server service reference
+ */
+//--------------------------------------------------------------------------------------------------
+le_msg_ServiceRef_t le_wifiClient_GetServiceRef
+(
+    void
+)
+{
+    return NULL;
+};
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get the client session reference for the current message
+ */
+//--------------------------------------------------------------------------------------------------
+le_msg_SessionRef_t le_wifiClient_GetClientSessionRef
+(
+    void
+)
+{
+    return (le_msg_SessionRef_t)0x1001;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Registers a function to be called whenever one of this service's sessions is closed by
+ * the client.  (STUBBED FUNCTION)
+
+ */
+//--------------------------------------------------------------------------------------------------
+le_msg_SessionEventHandlerRef_t MyAddServiceCloseHandler
+(
+    le_msg_ServiceRef_t             serviceRef, ///< [IN] Reference to the service.
+    le_msg_SessionEventHandler_t    handlerFunc,///< [IN] Handler function.
+    void*                           contextPtr  ///< [IN] Opaque pointer value to pass to handler.
+)
+{
+    return NULL;
+}
+
+//--------------------------------------------------------------------------------------------------
+// Secure storage service stubbing
+//--------------------------------------------------------------------------------------------------
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Stub for reading an item from secure storage.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_secStore_Read
+(
+    const char* name,               ///< [IN] Name of the secure storage item.
+    uint8_t* bufPtr,                ///< [OUT] Buffer to store the data in.
+    size_t* bufNumElementsPtr       ///< [INOUT] Size of buffer.
+)
+{
+    #define STUB_SECSTORE_ITEM_VALUE "mySecret"
+    *bufNumElementsPtr = strlen(STUB_SECSTORE_ITEM_VALUE);
+    memcpy(bufPtr, STUB_SECSTORE_ITEM_VALUE, *bufNumElementsPtr);
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Stub for writing an item to secure storage.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_secStore_Write
+(
+    const char* name,               ///< [IN] Name of the secure storage item.
+    const uint8_t* bufPtr,          ///< [IN] Buffer contain the data to store.
+    size_t bufNumElements           ///< [IN] Size of buffer.
+)
+{
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Stub for deleting an item from secure storage.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_secStore_Delete
+(
+    const char* name               ///< [IN] Name of the secure storage item.
+
+)
+{
+    return LE_OK;
+}
diff --git a/apps/tools/wifi/wifi/wifi.c b/apps/tools/wifi/wifi/wifi.c
index 19f6276..45e48eb 100644
--- a/apps/tools/wifi/wifi/wifi.c
+++ b/apps/tools/wifi/wifi/wifi.c
@@ -1,6 +1,6 @@
 //-------------------------------------------------------------------------------------------------
 /**
- * @file wifi_ap.c
+ * @file wifi.c
  *
  * WiFi Service Command line.
  *
@@ -62,7 +62,7 @@ COMPONENT_INIT
             }
             else if (strcmp(servicePtr, "ap") == 0)
             {
-                ExecuteWifiApCommand(commandPtr, le_arg_NumArgs());;
+                ExecuteWifiApCommand(commandPtr, le_arg_NumArgs());
             }
             else
             {
diff --git a/apps/tools/wifi/wifi/wifi_ap.c b/apps/tools/wifi/wifi/wifi_ap.c
index 7d2b46b..1f75785 100644
--- a/apps/tools/wifi/wifi/wifi_ap.c
+++ b/apps/tools/wifi/wifi/wifi_ap.c
@@ -33,10 +33,35 @@ void PrintApHelp(void)
         "\twifi ap stop\n"
 
         "To set the SSID of the WiFi access point:\n"
-        "\twifi ap setssid [SSID]\n"
+        "\twifi ap setssid [\"SSID\"]\n"
+
+        "To set the IEEE stdmask of the WiFi access point:\n"
+        "\twifi ap setstdmask [IEEEStdMask]\n"
+        "Bit mask for IEEEStdMask;\n"
+        "\t0x1:   IEEE 802.11a\n"
+        "\t0x2:   IEEE 802.11b\n"
+        "\t0x4:   IEEE 802.11g\n"
+        "\t0x8:   IEEE 802.11ad\n"
+        "\t0x10:  IEEE 802.11d\n"
+        "\t0x20:  IEEE 802.11h\n"
+        "\t0x40:  IEEE 802.11n\n"
+        "\t0x80:  IEEE 802.11ac\n"
+        "\t0x100: IEEE 802.11ax\n"
+        "\t0x200: IEEE 802.11w\n"
+
+        "To get the IEEE stdmask of the WiFi access point:\n"
+        "\twifi ap getstdmask\n"
 
         "To set the channel of the WiFi access point:\n"
         "\twifi ap setchannel [ChannelNo]\n"
+        "Values for ChannelNo;\n"
+        "\tbetween 1 and 14  for IEEE 802.11b/g\n"
+        "\tbetween 7 and 196 for IEEE 802.11a\n"
+        "\tbetween 1 and 6   for IEEE 802.11ad\n"
+        "\tSome legal restrictions might apply for your region\n"
+
+        "To set the countrycode of the WiFi access point:\n"
+        "\twifi ap setcountrycode [CountryCode]\n"
 
         "To set the security protocol used :\n"
         "\twifi ap setsecurityproto [SecuProto]\n"
@@ -179,6 +204,79 @@ void ExecuteWifiApCommand
             exit(EXIT_FAILURE);
         }
     }
+    else if (strcmp(commandPtr, "setstdmask") == 0)
+    {
+        // wifi ap setbitmask [IEEEStdMask]
+        const char *stdMaskPtr = le_arg_GetArg(2);
+        le_wifiAp_IeeeStdBitMask_t stdMask;
+        int8_t      hwMode = 0;
+        int8_t      numCheck = 0;
+
+        if (NULL == stdMaskPtr)
+        {
+            printf("ERROR: Missing or bad argument.\n");
+            exit(EXIT_FAILURE);
+        }
+
+        stdMask = strtol(stdMaskPtr, NULL, 0);
+        if (errno != 0)
+        {
+            printf("ERROR: Invalid argument.\n");
+            exit(EXIT_FAILURE);
+        }
+
+        hwMode = stdMask & 0x0F;
+        numCheck = (hwMode & 0x1) + ((hwMode >> 1) & 0x1) +
+                       ((hwMode >> 2) & 0x1) + ((hwMode >> 3) & 0x1);
+
+        // CAUTION: Hardware mode is exclusive. At least one mode should be set.
+        if ( 0 == numCheck )
+        {
+            printf("ERROR: No hardware mode is set.\n");
+            exit(EXIT_FAILURE);
+        }
+        if ( numCheck > 1 )
+        {
+            printf("ERROR: Only one hardware mode can be set.\n");
+            exit(EXIT_FAILURE);
+        }
+
+        // CAUTION: ieee80211ac=1 only works with hw_mode=a
+        if ((stdMask & LE_WIFIAP_BITMASK_IEEE_STD_AC) &&
+            (0 == (stdMask & LE_WIFIAP_BITMASK_IEEE_STD_A)))
+        {
+            printf("ERROR: ieee80211ac=1 only works with hw_mode=a.\n");
+            exit(EXIT_FAILURE);
+        }
+
+        if (LE_OK == (result = le_wifiAp_SetIeeeStandard(stdMask)))
+        {
+            printf("IEEEStdMask set to 0x%X.\n", stdMask);
+            exit(EXIT_SUCCESS);
+        }
+        else
+        {
+            printf("ERROR: le_wifiAp_SetIeeeStandard returns %d.\n", result);
+            exit(EXIT_FAILURE);
+        }
+    }
+    else if (strcmp(commandPtr, "getstdmask") == 0)
+    {
+        // wifi ap getbitmask [IEEEStdMask]
+        le_wifiAp_IeeeStdBitMask_t stdmask;
+
+        if (LE_OK == (result = le_wifiAp_GetIeeeStandard(&stdmask)))
+        {
+            printf("IEEEStdMask is 0x%X.\n", stdmask);
+            exit(EXIT_SUCCESS);
+        }
+        else
+        {
+            printf("ERROR: le_wifiAp_GetIeeeStandard returns %d.\n", result);
+            exit(EXIT_FAILURE);
+        }
+    }
+
     else if (strcmp(commandPtr, "setchannel") == 0)
     {
         // wifi ap setchannel [ChannelNo]
@@ -197,24 +295,45 @@ void ExecuteWifiApCommand
             printf("ERROR: Invalid argument.\n");
             exit(EXIT_FAILURE);
         }
-        // CAUTION: Range of channels value only valid for 2,4 GHz WiFi frequencies.
-        if ((channelNo < LE_WIFIDEFS_MIN_CHANNEL_VALUE) ||
-            (channelNo > LE_WIFIDEFS_MAX_CHANNEL_VALUE))
+        // CAUTION: Range of channels value is different with different hardware mode.
+        if (LE_OK == (result = le_wifiAp_SetChannel(channelNo)))
+        {
+            printf("Channel set to %d.\n", channelNo);
+            exit(EXIT_SUCCESS);
+        }
+        else
+        {
+            printf("Please check hardware mode and channel range.\n");
+            printf("ERROR: le_wifiAp_SetChannel returns %d.\n", result);
+            exit(EXIT_FAILURE);
+        }
+    }
+    else if (strcmp(commandPtr, "setcountrycode") == 0)
+    {
+        // wifi ap setcountrycode [CountryCode]
+        const char *countryCodePtr = le_arg_GetArg(2);
+
+        if (NULL == countryCodePtr)
+        {
+            printf("ERROR: Missing or bad argument.\n");
+            exit(EXIT_FAILURE);
+        }
+        length = strlen(countryCodePtr);
+        if (length != LE_WIFIDEFS_ISO_COUNTRYCODE_LENGTH)
         {
-            printf("ERROR: Valid channel is between %d and %d.\n",
-                LE_WIFIDEFS_MIN_CHANNEL_VALUE,
-                LE_WIFIDEFS_MAX_CHANNEL_VALUE);
+            printf("ERROR: Countrycode length must be %d.\n",
+                   LE_WIFIDEFS_ISO_COUNTRYCODE_LENGTH);
             exit(EXIT_FAILURE);
         }
 
-        if (LE_OK == (result = le_wifiAp_SetChannel(channelNo)))
+        if (LE_OK == (result = le_wifiAp_SetCountryCode(countryCodePtr)))
         {
-            printf("Channel set to %d.\n", channelNo);
+            printf("Countrycode set to %s.\n", countryCodePtr);
             exit(EXIT_SUCCESS);
         }
         else
         {
-            printf("ERROR: le_wifiAp_SetChannel returns %d.\n", result);
+            printf("ERROR: le_wifiAp_SetCountryCode returns %d.\n", result);
             exit(EXIT_FAILURE);
         }
     }
diff --git a/apps/tools/wifi/wifi/wifi_client.c b/apps/tools/wifi/wifi/wifi_client.c
index 104fc87..43eca8d 100644
--- a/apps/tools/wifi/wifi/wifi_client.c
+++ b/apps/tools/wifi/wifi/wifi_client.c
@@ -21,14 +21,22 @@
  * Event handler reference.
  */
 //--------------------------------------------------------------------------------------------------
-static le_wifiClient_NewEventHandlerRef_t ScanHdlrRef = NULL;
+static le_wifiClient_ConnectionEventHandlerRef_t ScanHdlrRef = NULL;
 
 //--------------------------------------------------------------------------------------------------
 /**
  * Event handler reference.
  */
 //--------------------------------------------------------------------------------------------------
-static le_wifiClient_NewEventHandlerRef_t ConnectHdlrRef = NULL;
+static le_wifiClient_ConnectionEventHandlerRef_t ConnectHdlrRef = NULL;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Indicator of whether wifiClient is in the middle of a scan
+ */
+//--------------------------------------------------------------------------------------------------
+static bool ScanInProgress = false;
+
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -38,7 +46,7 @@ static le_wifiClient_NewEventHandlerRef_t ConnectHdlrRef = NULL;
 //--------------------------------------------------------------------------------------------------
 static void WifiClientConnectEventHandler
 (
-    le_wifiClient_Event_t event,
+    const le_wifiClient_EventInd_t* wifiEventPtr,
         ///< [IN]
         ///< WiFi event to process
     void* contextPtr
@@ -46,21 +54,47 @@ static void WifiClientConnectEventHandler
         ///< Associated event context
 )
 {
-    LE_DEBUG("WiFi client event received");
-    switch(event)
+    LE_DEBUG("WiFi client event %d\n", wifiEventPtr->event);
+    switch(wifiEventPtr->event)
     {
         case LE_WIFICLIENT_EVENT_CONNECTED:
         {
-            printf("CONNECTED.\n");
-            le_wifiClient_RemoveNewEventHandler(ConnectHdlrRef);
+            printf("CONNECTED: interface: %s, bssid: %s\n",
+                   wifiEventPtr->ifName,
+                   wifiEventPtr->apBssid);
+            le_wifiClient_RemoveConnectionEventHandler(ConnectHdlrRef);
             exit(EXIT_SUCCESS);
         }
         break;
 
         case LE_WIFICLIENT_EVENT_DISCONNECTED:
         {
-            printf("DISCONNECTED.\n");
-            le_wifiClient_RemoveNewEventHandler(ConnectHdlrRef);
+            printf("DISCONNECTED: interface: %s, bssid: %s, disconnectionCause: ",
+                   wifiEventPtr->ifName,
+                   wifiEventPtr->apBssid);
+
+            switch(wifiEventPtr->disconnectionCause)
+            {
+               case 1:
+                    printf("WiFi Client request to disconnect\n");
+                    break;
+               case 2:
+                    printf("WiFi card is detached\n");
+                    break;
+               case 3:
+                    printf("WiFi driver has been removed\n");
+                    break;
+               case 4:
+                    printf("Beacon loss due to poor SINR\n");
+                    break;
+               case 5:
+                    printf("Disconnected by AP\n");
+                    break;
+               default:
+                    printf("Unknown reason\n");
+            }
+
+            le_wifiClient_RemoveConnectionEventHandler(ConnectHdlrRef);
             exit(EXIT_SUCCESS);
         }
         break;
@@ -80,7 +114,7 @@ static void WifiClientConnectEventHandler
         break;
 
         default:
-            LE_ERROR("ERROR Unknown event %d", event);
+            LE_ERROR("ERROR Unknown event %d", wifiEventPtr->event);
         break;
     }
 }
@@ -147,7 +181,7 @@ static void WifiReadScanResults
 //--------------------------------------------------------------------------------------------------
 static void WifiClientScanEventHandler
 (
-    le_wifiClient_Event_t event,
+    const le_wifiClient_EventInd_t* wifiEventPtr,
         ///< [IN]
         ///< WiFi event to process
     void* contextPtr
@@ -156,30 +190,55 @@ static void WifiClientScanEventHandler
 )
 {
     LE_DEBUG("WiFi Client event received");
-    switch(event)
+    switch(wifiEventPtr->event)
     {
         case LE_WIFICLIENT_EVENT_CONNECTED:
         {
-            LE_DEBUG("FYI: Got EVENT CONNECTED, was while waiting for SCAN.");
+            LE_DEBUG("FYI: Got EVENT CONNECTED");
         }
         break;
 
         case LE_WIFICLIENT_EVENT_DISCONNECTED:
         {
-            LE_DEBUG("FYI: Got EVENT DISCONNECTED, was while waiting for SCAN.");
+            LE_DEBUG("FYI: Got EVENT DISCONNECTED");
         }
         break;
 
         case LE_WIFICLIENT_EVENT_SCAN_DONE:
         {
+            if (!ScanInProgress)
+            {
+                // Ignore scan result posting by wifiClient not initiated here
+                LE_DEBUG("Ignore wifi scan result posting not initiated by command");
+                break;
+            }
+
             LE_DEBUG("LE_WIFICLIENT_EVENT_SCAN_DONE: Now read the results ");
+            ScanInProgress = false;
             WifiReadScanResults();
-            le_wifiClient_RemoveNewEventHandler(ScanHdlrRef);
+            le_wifiClient_RemoveConnectionEventHandler(ScanHdlrRef);
             exit(EXIT_SUCCESS);
         }
         break;
+
+        case LE_WIFICLIENT_EVENT_SCAN_FAILED:
+        {
+            if (!ScanInProgress)
+            {
+                // Ignore scan result posting by wifiClient not initiated here
+                LE_DEBUG("Ignore wifi scan result posting not initiated by command");
+                break;
+            }
+
+            printf("ERROR: Scan failed.\n");
+            ScanInProgress = false;
+            le_wifiClient_RemoveConnectionEventHandler(ScanHdlrRef);
+            exit(EXIT_FAILURE);
+        }
+        break;
+
         default:
-            LE_ERROR("ERROR Unknown event %d", event);
+            LE_ERROR("ERROR Unknown event %d", wifiEventPtr->event);
         break;
     }
 }
@@ -208,6 +267,9 @@ void PrintClientHelp(void)
            "To connect to an access point set in 'create':\n"
            "\twifi client connect [REF]\n"
 
+           "To get the signal strength of the AccessPoint:\n"
+           "\twifi client signal [REF]\n"
+
            "To set security protocol\n"
            "\twifi client setsecurityproto [REF] [SecuProto]\n"
 
@@ -272,11 +334,17 @@ void ExecuteWifiClientCommand
     else if (strcmp(commandPtr, "start") == 0)
     {
 
-        if (LE_OK == le_wifiClient_Start())
+        result = le_wifiClient_Start();
+        if (LE_OK == result)
         {
             printf("successfully called start.\n");
             exit(EXIT_SUCCESS);
         }
+        else if (LE_BUSY == result)
+        {
+            printf("already started.\n");
+            exit(EXIT_SUCCESS);
+        }
         else
         {
             printf("ERROR: le_wifiClient_Start returns ERROR.\n");
@@ -298,16 +366,23 @@ void ExecuteWifiClientCommand
     }
     else if (strcmp(commandPtr, "scan") == 0)
     {
+        if (ScanInProgress)
+        {
+            printf("ERROR: le_wifiClient_Scan already in progress.\n");
+            exit(EXIT_FAILURE);
+        }
+
         // Command: wifi client scan
         printf("starting scan.\n");
 
         // Add a handler function to handle message reception
-        ScanHdlrRef=le_wifiClient_AddNewEventHandler(WifiClientScanEventHandler, NULL);
-
-
-        if (LE_OK != (result= le_wifiClient_Scan()))
+        ScanHdlrRef = le_wifiClient_AddConnectionEventHandler(WifiClientScanEventHandler, NULL);
+        ScanInProgress = true;
+        if (LE_OK != (result = le_wifiClient_Scan()))
         {
             printf("ERROR: le_wifiClient_Scan returns %d.\n", result);
+            ScanInProgress = false;
+            le_wifiClient_RemoveConnectionEventHandler(ScanHdlrRef);
             exit(EXIT_FAILURE);
         }
     }
@@ -390,7 +465,8 @@ void ExecuteWifiClientCommand
         rc1 = sscanf(refPtr, "%x", (unsigned int *)&apRef);
 
         // Add a handler function to handle message reception
-        ConnectHdlrRef = le_wifiClient_AddNewEventHandler(WifiClientConnectEventHandler, NULL);
+        ConnectHdlrRef =
+            le_wifiClient_AddConnectionEventHandler(WifiClientConnectEventHandler, NULL);
 
         if ((1 == rc1) && (LE_OK == (result = le_wifiClient_Connect(apRef))))
         {
@@ -399,21 +475,49 @@ void ExecuteWifiClientCommand
         else
         {
             printf("ERROR: le_wifiClient_Connect returns error code %d.\n", result);
-            le_wifiClient_RemoveNewEventHandler(ConnectHdlrRef);
+            le_wifiClient_RemoveConnectionEventHandler(ConnectHdlrRef);
             exit(EXIT_FAILURE);
         }
     }
     else if (strcmp(commandPtr, "disconnect") == 0)
     {
         // Command: wifi client disconnect
+        ConnectHdlrRef =
+            le_wifiClient_AddConnectionEventHandler(WifiClientConnectEventHandler, NULL);
+
         if (LE_OK == (result = le_wifiClient_Disconnect()))
         {
-            printf("WiFi client disconnected.\n");
-            exit(EXIT_SUCCESS);
+            printf("WiFi client request disconnect done.\n");
         }
         else
         {
             printf("ERROR: le_wifiClient_Disconnect returns error code %d.\n", result);
+            le_wifiClient_RemoveConnectionEventHandler(ConnectHdlrRef);
+            exit(EXIT_FAILURE);
+        }
+    }
+    else if (strcmp(commandPtr, "signal") == 0)
+    {
+        // Command: wifi client get the signal strength of the Access Point
+        const char*                     refPtr = le_arg_GetArg(2);
+        le_wifiClient_AccessPointRef_t  apRef  = NULL;
+
+        if (NULL == refPtr)
+        {
+            printf("ERROR. Missing argument.\n");
+            exit(EXIT_FAILURE);
+        }
+
+        rc1 = sscanf(refPtr, "%x", (unsigned int *)&apRef);
+
+        if (1 == rc1)
+        {
+            printf("SignalStrength %d\n", le_wifiClient_GetSignalStrength(apRef));
+            exit(EXIT_SUCCESS);
+        }
+        else
+        {
+            printf("ERROR: wrong acess point.\n");
             exit(EXIT_FAILURE);
         }
     }
@@ -585,7 +689,7 @@ void ExecuteWifiClientCommand
         }
 
         rc1 = sscanf(refPtr, "%x", (unsigned int *)&apRef);
-        result = le_wifiClient_SetPreSharedKey(apRef, wepKeyPtr);
+        result = le_wifiClient_SetWepKey(apRef, wepKeyPtr);
 
         if ((1 == rc1) && (LE_OK == result))
         {
@@ -594,7 +698,7 @@ void ExecuteWifiClientCommand
         }
         else
         {
-            printf("ERROR: le_wifiClient_SetPreSharedKey returns %d.\n", result);
+            printf("ERROR: le_wifiClient_SetWepKey returns %d.\n", result);
             exit(EXIT_FAILURE);
         }
     }
diff --git a/moduleDefs b/moduleDefs
index 6d7d810..376c46e 100644
--- a/moduleDefs
+++ b/moduleDefs
@@ -1,9 +1,7 @@
-$(info Module: WiFi)
-
 export LEGATO_WIFI_ROOT := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))
 
-# Check wether the version is already defined.
-ifeq ($(origin LEGATO_WIFI_VERSION), undefined)
+# Check whether the version is already defined.
+ifeq ($(origin LEGATO_WIFI_VERSION),undefined)
   # If not, try to define it through Git information
   LEGATO_WIFI_VERSION := $(shell (git --git-dir=$(LEGATO_WIFI_ROOT)/.git describe --tags || git rev-parse HEAD) 2> /dev/null)
 
@@ -17,49 +15,3 @@ ifeq ($(origin LEGATO_WIFI_VERSION), undefined)
   # And finally, export it.
   export LEGATO_WIFI_VERSION
 endif
-
-# this variable goes from environment -> cmake -> Doxygen.
-# It can be used in Legato Doxygen code to conditionally add MangOH links etc.
-# \if EXTERNAL_DOXYGEN_DEFINE
-# ....
-# \endif
-export EXTERNAL_DOXYGEN_DEFINE = EXTERNAL_DOXYGEN_DEFINE
-export EXTERNAL_DOXYGEN_ROOT = $(LEGATO_WIFI_ROOT)
-
-######### Platform Adaptor values
-# values are the names of the subdirectories in /WiFi/service/platformAdaptor/$(LEGATO_WIFI_PA)
-# currently available :
-# ti - running hardware
-# ti_simu - running a simulated Access Point.  (Wifi Client to remains to be simulated)
-ifndef LEGATO_WIFI_PA
-  export LEGATO_WIFI_PA = ti
-endif
-
-# Only use WiFi module on WP750x/WP85
-ifndef LEGATO_WIFI_BUILD
-  LEGATO_WIFI_BUILD = 0
-  ifeq ($(TARGET),wp750x)
-    LEGATO_WIFI_BUILD = 1
-  endif
-  ifeq ($(TARGET),wp85)
-    LEGATO_WIFI_BUILD = 1
-  endif
-  ifeq ($(TARGET),wp76xx)
-    LEGATO_WIFI_BUILD = 1
-  endif
-  ifeq ($(TARGET),wp77xx)
-    LEGATO_WIFI_BUILD = 1
-  endif
-endif
-
-ifeq ($(LEGATO_WIFI_BUILD),1)
-  $(info ********************* VERSION ********************)
-  $(info Legato WiFi version: $(LEGATO_WIFI_VERSION))
-  $(info **************************************************)
-
-  ifndef SDEF_TO_USE
-    # Override the default sdef file to use the MangOH one
-    export SDEF_TO_USE = $(LEGATO_WIFI_ROOT)/wifi.sdef
-  endif
-endif
-
diff --git a/service/Makefile b/service/Makefile
index 6dddba4..fa7332c 100644
--- a/service/Makefile
+++ b/service/Makefile
@@ -1,7 +1,7 @@
 TARGETS := $(MAKECMDGOALS)
 
 export LEGATO_WIFI_ROOT ?= $(PWD)/..
-export LEGATO_WIFI_PA ?= ti
+export LEGATO_WIFI_PA ?= $(LEGATO_WIFI_ROOT)/service/platformAdaptor/ti
 
 .PHONY: all $(TARGETS)
 all: $(TARGETS)
diff --git a/service/daemon/Component.cdef b/service/daemon/Component.cdef
index 1f53ee3..bcd3144 100644
--- a/service/daemon/Component.cdef
+++ b/service/daemon/Component.cdef
@@ -1,3 +1,12 @@
+requires:
+{
+    api:
+    {
+        ${LEGATO_ROOT}/interfaces/le_cfg.api
+        ${LEGATO_ROOT}/interfaces/le_secStore.api
+    }
+}
+
 provides:
 {
     api:
@@ -12,8 +21,8 @@ sources:
     wifiService.c
     le_wifiClient.c
     le_wifiAp.c
-    ${LEGATO_WIFI_ROOT}/service/platformAdaptor/${LEGATO_WIFI_PA}/pa_wifi_client_ti.c
-    ${LEGATO_WIFI_ROOT}/service/platformAdaptor/${LEGATO_WIFI_PA}/pa_wifi_ap_ti.c
+    ${LEGATO_WIFI_ROOT}/service/platformAdaptor/common/pa_wifi_client.c
+    ${LEGATO_WIFI_ROOT}/service/platformAdaptor/common/pa_wifi_ap.c
 }
 
 cflags:
@@ -26,6 +35,6 @@ bundles:
     file:
     {
         // Script file implementing Wifi PA
-        [x] ${LEGATO_WIFI_ROOT}/service/platformAdaptor/ti/pa_wifi.sh  pa_wifi.sh
+        [x] ${LEGATO_WIFI_PA}  pa_wifi
     }
 }
diff --git a/service/daemon/le_wifiAp.c b/service/daemon/le_wifiAp.c
index 0990c5d..98aadcd 100644
--- a/service/daemon/le_wifiAp.c
+++ b/service/daemon/le_wifiAp.c
@@ -126,6 +126,8 @@ void le_wifiAp_RemoveNewEventHandler
  *
  * @return LE_FAULT         The function failed.
  * @return LE_OK            The function succeeded.
+ * @return LE_NOT_FOUND     The WiFi card is absent.
+ * @return LE_NOT_POSSIBLE  The WiFi card may not work.
  *
  */
 //--------------------------------------------------------------------------------------------------
@@ -272,26 +274,96 @@ le_result_t le_wifiAp_SetDiscoverable
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Set the WiFi channel used to communicate with the access point.
- * Default value is 1.
- * Some legal restrictions for values 12 - 14 might apply for your region.
- *
- * @return LE_OUT_OF_RANGE Requested channel number is out of range.
- * @return LE_OK           Function succeeded.
+ * Set which WiFi channel to use.
+ * Default number is 7.
+ * Some legal restrictions might apply for your region.
+ * The channel number must be between 1 and 14 for IEEE 802.11b/g.
+ * The channel number must be between 7 and 196 for IEEE 802.11a.
+ * The channel number must be between 1 and 6 for IEEE 802.11ad.
+ * @return
+ *      - LE_OUT_OF_RANGE if requested channel number is out of range.
+ *      - LE_OK if the function succeeded.
  *
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiAp_SetChannel
 (
-    int8_t channelNumber
+    uint16_t channelNumber
         ///< [IN]
-        ///< the channel number must be between 1 and 14.
+        ///< the channel number.
 )
 {
     return pa_wifiAp_SetChannel(channelNumber);
 }
 
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set which IEEE standard to use.
+ * Default hardware mode is IEEE 802.11g.
+ *
+ * @return
+ *      - LE_BAD_PARAMETER if invalid IEEE standard is set.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiAp_SetIeeeStandard
+(
+    le_wifiAp_IeeeStdBitMask_t stdMask
+        ///< [IN]
+        ///< Bit mask for the IEEE standard.
+)
+{
+    return pa_wifiAp_SetIeeeStandard(stdMask);
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get which IEEE standard was set.
+ * Default hardware mode is IEEE 802.11g.
+ *
+ * @return
+ *      - LE_FAULT if the function failed.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiAp_GetIeeeStandard
+(
+    le_wifiAp_IeeeStdBitMask_t *stdMaskPtr
+        ///< [OUT]
+        ///< Bit mask for the IEEE standard.
+)
+{
+    if ( NULL == stdMaskPtr )
+    {
+        LE_WARN("stdMaskPtr is NULL.");
+        return LE_FAULT;
+    }
+    return pa_wifiAp_GetIeeeStandard(stdMaskPtr);
+}
+
+/**
+ * Set what country code to use for regulatory domain.
+ * ISO/IEC 3166-1 Alpha-2 code is used.
+ * Default country code is US.
+ * @return
+ *      - LE_FAULT if the function failed.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiAp_SetCountryCode
+(
+    const char *countryCodePtr
+        ///< [IN]
+        ///< the country code.
+)
+{
+    return pa_wifiAp_SetCountryCode(countryCodePtr);
+}
+
 //--------------------------------------------------------------------------------------------------
 /**
  *  WiFi access point component initialization.
diff --git a/service/daemon/le_wifiClient.c b/service/daemon/le_wifiClient.c
index bdcce1d..73b566c 100644
--- a/service/daemon/le_wifiClient.c
+++ b/service/daemon/le_wifiClient.c
@@ -12,20 +12,36 @@
 
 #include "pa_wifi.h"
 
+
 //--------------------------------------------------------------------------------------------------
 /**
- * The initial allocated AP:s at system start.
- * Note that the pool will grow automatically if it is needed.
+ * The following are Wifi client's config tree path and node definitions
  */
 //-------------------------------------------------------------------------------------------------
-#define INIT_AP_COUNT 32
+#define CFG_TREE_ROOT_DIR           "wifiService:"
+#define CFG_PATH_WIFI               "wifi/channel"
+#define CFG_NODE_HIDDEN_SSID        "hidden"
+#define CFG_NODE_SECPROTOCOL        "secProtocol"
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * The following are Wifi client's secured store's item root and node definitions
+ */
+//-------------------------------------------------------------------------------------------------
+#define SECSTORE_WIFI_ITEM_ROOT     "wifiService/channel"
+#define SECSTORE_NODE_PASSPHRASE    "passphrase"
+#define SECSTORE_NODE_PSK           "preSharedKey"
+#define SECSTORE_NODE_WEP_KEY       "wepKey"
+#define SECSTORE_NODE_USERNAME      "userName"
+#define SECSTORE_NODE_USERPWD       "userPassword"
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Value of signal strength that indicates that no value was found.
+ * The initial allocated number of APs at system start.
+ * Note that the pool will grow automatically if it is needed.
  */
 //-------------------------------------------------------------------------------------------------
-#define SIGNAL_STRENGTH_DEFAULT  (0xfff)
+#define INIT_AP_COUNT 32
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -96,11 +112,26 @@ static le_result_t ScanResult = LE_OK;
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Event ID for WiFi Event message notification.
+ * Event ID for WiFi Event notification.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+static le_event_Id_t WifiEventId;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Event ID for WiFi Event indication notification.
  *
  */
 //--------------------------------------------------------------------------------------------------
-static le_event_Id_t NewWifiEventId;
+static le_event_Id_t WifiEventIndicationId;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Pool for WifiClient state events reporting.
+ */
+//--------------------------------------------------------------------------------------------------
+static le_mem_PoolRef_t WifiEventPool;
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -110,10 +141,53 @@ static le_event_Id_t NewWifiEventId;
 //--------------------------------------------------------------------------------------------------
 static uint32_t ClientStartCount = 0;
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * This CurrentConnection records the selected connection to get established via an API call to
+ * le_wifiClient_Connect().  But note that it doesn't necessarily mean that this connection has
+ * been successfully established, since the attempt to connect might fail, take time to finish, etc.
+ * Its value will be reset after an API call to le_wifiClient_Disconnect() or le_wifiClient_Stop().
+ * Thus, this CurrentConnection variable refers more to the selected SSID to get connected instead.
+ */
+//--------------------------------------------------------------------------------------------------
+static le_wifiClient_AccessPointRef_t CurrentConnection = NULL;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * WLAN interface being used to do WiFi scan.
+ */
+//--------------------------------------------------------------------------------------------------
+static char scanIfName[LE_WIFIDEFS_MAX_IFNAME_BYTES] = {0};
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * CallBack for PA WiFi Event Indications.
+ */
+//--------------------------------------------------------------------------------------------------
+static void PaEventIndicationHandler
+(
+    le_wifiClient_EventInd_t* wifiEventIndicationPtr,
+    void *contextPtr
+)
+{
+    LE_DEBUG("WiFi event: %d, interface: %s, bssid: %s",
+            wifiEventIndicationPtr->event,
+            wifiEventIndicationPtr->ifName,
+            wifiEventIndicationPtr->apBssid);
+
+    if (LE_WIFICLIENT_EVENT_DISCONNECTED == wifiEventIndicationPtr->event)
+    {
+        LE_DEBUG("disconnectCause: %d", wifiEventIndicationPtr->disconnectionCause);
+    }
+
+    le_event_ReportWithRefCounting(WifiEventIndicationId, wifiEventIndicationPtr);
+}
 
 //--------------------------------------------------------------------------------------------------
 /**
  * CallBack for PA Events.
+ * @deprecated pa_wifiClient_AddEventHandler() should not be used anymore.
+ * It has been replaced by pa_wifiClient_AddEventIndHandler().
  */
 //--------------------------------------------------------------------------------------------------
 static void PaEventHandler
@@ -124,7 +198,7 @@ static void PaEventHandler
 {
     LE_DEBUG("Event: %d ", event);
 
-    le_event_Report(NewWifiEventId, (void *)&event, sizeof(le_wifiClient_Event_t));
+    le_event_Report(WifiEventId, (void *)&event, sizeof(le_wifiClient_Event_t));
 }
 
 //--------------------------------------------------------------------------------------------------
@@ -198,7 +272,7 @@ static le_wifiClient_AccessPointRef_t FindAccessPointRefFromSsid
             FoundAccessPoint_t *apPtr = (FoundAccessPoint_t *)le_ref_Lookup(ScanApRefMap, apRef);
             if (NULL != apPtr)
             {
-                if ((apPtr->accessPoint.ssidLength == ssidNumElements))
+                if (apPtr->accessPoint.ssidLength == ssidNumElements)
                 {
                     if (0 == memcmp(apPtr->accessPoint.ssidBytes, ssidPtr, ssidNumElements))
                     {
@@ -239,10 +313,13 @@ static le_wifiClient_AccessPointRef_t AddAccessPointToApRefMap
 
         if (NULL != oldAccessPointPtr)
         {
-            LE_DEBUG("Already exists %p. Update  SignalStrength %d",
-                returnedRef, apPtr->signalStrength);
+            LE_DEBUG("Already exists %p. Update SignalStrength %d, SSID '%s'",
+                     returnedRef, apPtr->signalStrength, &apPtr->ssidBytes[0]);
 
             oldAccessPointPtr->accessPoint.signalStrength = apPtr->signalStrength;
+            oldAccessPointPtr->accessPoint.ssidLength = apPtr->ssidLength;
+            memcpy(&oldAccessPointPtr->accessPoint.ssidBytes, &apPtr->ssidBytes,
+                   apPtr->ssidLength);
             oldAccessPointPtr->foundInLatestScan = true;
         }
 
@@ -288,7 +365,6 @@ static le_wifiClient_AccessPointRef_t AddAccessPointToApRefMap
  *  Frees one members of the access point and the corresponding access points memory
  */
 //--------------------------------------------------------------------------------------------------
-
 static void RemoveAccessPoint
 (
     le_wifiClient_AccessPointRef_t apRef
@@ -313,7 +389,6 @@ static void RemoveAccessPoint
  *  le_wifiClient_Create()
  */
 //--------------------------------------------------------------------------------------------------
-
 static void ReleaseAllAccessPoints
 (
     void
@@ -349,7 +424,6 @@ static void ReleaseAllAccessPoints
  *
  */
 //--------------------------------------------------------------------------------------------------
-
 static void MarkAllAccessPointsOld
 (
     void
@@ -370,7 +444,7 @@ static void MarkAllAccessPointsOld
 
             if (apPtr != NULL)
             {
-                apPtr->accessPoint.signalStrength = SIGNAL_STRENGTH_DEFAULT;
+                apPtr->accessPoint.signalStrength = LE_WIFICLIENT_NO_SIGNAL_STRENGTH;
                 apPtr->foundInLatestScan = false;
                 LE_DEBUG("Marking %p as old", apRef);
                 counter++;
@@ -421,8 +495,8 @@ static void *ScanThread
     FoundWifiApCount = 0;
 
     MarkAllAccessPointsOld();
-
-    while (LE_OK == (paResult = pa_wifiClient_GetScanResult(&accessPoint)))
+    memset(scanIfName, 0, LE_WIFIDEFS_MAX_IFNAME_BYTES);
+    while (LE_OK == (paResult = pa_wifiClient_GetScanResult(&accessPoint, scanIfName)))
     {
         if (AddAccessPointToApRefMap(&accessPoint) == NULL)
         {
@@ -439,7 +513,6 @@ static void *ScanThread
     {
         LE_ERROR("pa_wifiClient_ScanDone() failed (%d)", paResult);
         *scanResultPtr = paResult;
-        return NULL;
     }
 
     return NULL;
@@ -458,19 +531,27 @@ static void ScanThreadDestructor
 {
     le_result_t scanResult = *((le_result_t*)context);
 
-    LE_DEBUG("Scan thread exited.");
+    LE_DEBUG("Destruct scan thread");
     ScanThreadRef = NULL;
+    le_wifiClient_EventInd_t* wifiEventIndicationPtr = le_mem_ForceAlloc(WifiEventPool);
 
     if (scanResult == LE_OK)
     {
-        // use the PA callback to generate the event.
-        PaEventHandler(LE_WIFICLIENT_EVENT_SCAN_DONE, NULL);
+        wifiEventIndicationPtr->event = LE_WIFICLIENT_EVENT_SCAN_DONE;
     }
     else
     {
         LE_WARN("Scan failed");
-        PaEventHandler(LE_WIFICLIENT_EVENT_SCAN_FAILED, NULL);
+        wifiEventIndicationPtr->event = LE_WIFICLIENT_EVENT_SCAN_FAILED;
     }
+
+    wifiEventIndicationPtr->disconnectionCause = LE_WIFICLIENT_UNKNOWN_CAUSE;
+    strncpy(wifiEventIndicationPtr->ifName, scanIfName, LE_WIFIDEFS_MAX_IFNAME_LENGTH);
+    wifiEventIndicationPtr->ifName[LE_WIFIDEFS_MAX_IFNAME_LENGTH] = '\0';
+    wifiEventIndicationPtr->apBssid[0] = '\0';
+    PaEventIndicationHandler(wifiEventIndicationPtr, NULL);
+
+    PaEventHandler(wifiEventIndicationPtr->event, NULL);
 }
 
 
@@ -486,8 +567,6 @@ static void CloseSessionEventHandler
     void                *contextPtr
 )
 {
-    LE_DEBUG("sessionRef %p GetFirstSessionRef %p", sessionRef, GetFirstSessionRef);
-
     if (sessionRef == GetFirstSessionRef)
     {
         GetFirstSessionRef = NULL;
@@ -506,11 +585,13 @@ static bool IsScanRunning(void)
     return (NULL != ScanThreadRef);
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * The first-layer WiFi Client Event Handler.
  *
+ * @deprecated le_wifiClient_AddNewEventHandler() should not be used anymore.
+ *
+ * It has been replaced by le_wifiClient_AddConnectionEventHandler().
  */
 //--------------------------------------------------------------------------------------------------
 static void FirstLayerWifiClientEventHandler
@@ -533,6 +614,33 @@ static void FirstLayerWifiClientEventHandler
     }
 }
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * The first-layer WiFi Client Connection Event Handler.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+static void FirstLayerWifiClientConnectionEventHandler
+(
+    void *reportPtr,
+    void *secondLayerHandlerFunc
+)
+{
+    le_wifiClient_EventInd_t*  wifiEventPtr = reportPtr;
+    le_wifiClient_ConnectionEventHandlerFunc_t  clientHandlerFunc = secondLayerHandlerFunc;
+
+
+    if (NULL != wifiEventPtr)
+    {
+        clientHandlerFunc(wifiEventPtr, le_event_GetContextPtr());
+    }
+    else
+    {
+        LE_WARN("wifiEventPtr is NULL");
+    }
+    // The reportPtr is a reference counted object, so need to release it
+    le_mem_Release(reportPtr);
+}
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -563,7 +671,11 @@ static bool WasApFoundInLastScan
 /**
  * Add handler function for EVENT 'le_wifiClient_NewEvent'
  *
- * This event provide information on Wfifi Client event changes.
+ * This event provide information on Wifi Client event changes.
+ *
+ * @deprecated le_wifiClient_AddNewEventHandler() should not be used anymore.
+ *
+ * It has been replaced by le_wifiClient_AddConnectionEventHandler().
  */
 //--------------------------------------------------------------------------------------------------
 le_wifiClient_NewEventHandlerRef_t le_wifiClient_AddNewEventHandler
@@ -589,18 +701,63 @@ le_wifiClient_NewEventHandlerRef_t le_wifiClient_AddNewEventHandler
     }
 
     handlerRef = le_event_AddLayeredHandler("NewWiFiClientMsgHandler",
-        NewWifiEventId,
-        FirstLayerWifiClientEventHandler,
-        (le_event_HandlerFunc_t)handlerFuncPtr);
+                                            WifiEventId,
+                                            FirstLayerWifiClientEventHandler,
+                                            (le_event_HandlerFunc_t)handlerFuncPtr);
 
     le_event_SetContextPtr(handlerRef, contextPtr);
 
     return (le_wifiClient_NewEventHandlerRef_t)(handlerRef);
 }
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function must be called to register an handler for WiFi connection state change.
+ *
+ * @return A handler reference, which is only needed for later removal of the handler.
+ *
+ * @note Doesn't return on failure, so there's no need to check the return value for errors.
+ */
+//--------------------------------------------------------------------------------------------------
+le_wifiClient_ConnectionEventHandlerRef_t le_wifiClient_AddConnectionEventHandler
+(
+    le_wifiClient_ConnectionEventHandlerFunc_t handlerFuncPtr,
+        ///< [IN]
+        ///< Event handling function
+
+    void *contextPtr
+        ///< [IN]
+        ///< Associated event context
+)
+{
+    le_event_HandlerRef_t handlerRef;
+
+    // Note: THIS ONE REGISTERS THE CB function..
+    LE_DEBUG("Add wifi connection event handler");
+
+    if (handlerFuncPtr == NULL)
+    {
+        LE_KILL_CLIENT("handlerFuncPtr is NULL !");
+        return NULL;
+    }
+
+    handlerRef = le_event_AddLayeredHandler("WiFiClientMsgHandler",
+                                            WifiEventIndicationId,
+                                            FirstLayerWifiClientConnectionEventHandler,
+                                            (le_event_HandlerFunc_t)handlerFuncPtr);
+
+    le_event_SetContextPtr(handlerRef, contextPtr);
+
+    return (le_wifiClient_ConnectionEventHandlerRef_t)(handlerRef);
+}
+
 //--------------------------------------------------------------------------------------------------
 /**
  * Remove handler function for EVENT 'le_wifiClient_NewEvent'
+ *
+ * @deprecated le_wifiClient_AddNewEventHandler() should not be used anymore.
+ *
+ * It has been replaced by le_wifiClient_AddConnectionEventHandler().
  */
 //--------------------------------------------------------------------------------------------------
 void le_wifiClient_RemoveNewEventHandler
@@ -614,14 +771,32 @@ void le_wifiClient_RemoveNewEventHandler
     le_event_RemoveHandler((le_event_HandlerRef_t)handlerRef);
 }
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Remove handler function for EVENT 'le_wifiClient_ConnectionEvent'
+ */
+//--------------------------------------------------------------------------------------------------
+void le_wifiClient_RemoveConnectionEventHandler
+(
+    le_wifiClient_ConnectionEventHandlerRef_t handlerRef
+        ///< [IN]
+        ///< Reference of the event handler to remove
+)
+{
+    LE_DEBUG("Remove event handler");
+    le_event_RemoveHandler((le_event_HandlerRef_t)handlerRef);
+}
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Start the WIFI device.
- *
- * @return LE_FAULT         The function failed to start the WIFI module.
- * @return LE_OK            The function succeeded.
+ * Starts the WIFI device.
  *
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_FAULT          Function failed.
+ *      - LE_BUSY           The WiFi device is already started.
+ *      - LE_NOT_FOUND      The WiFi device is absent.
+ *      - LE_NOT_POSSIBLE   The WiFi device may not work.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_Start
@@ -629,7 +804,7 @@ le_result_t le_wifiClient_Start
     void
 )
 {
-    le_result_t result = LE_OK;
+    le_result_t result;
 
     // Only the first client starts the WIFI module
     if (!ClientStartCount)
@@ -638,21 +813,20 @@ le_result_t le_wifiClient_Start
         if (LE_OK == result)
         {
             LE_DEBUG("WIFI client started successfully");
+            // Increment the number of clients calling this start function
+            ClientStartCount++;
         }
         else
         {
-            LE_ERROR("Unable to start WIFI client. Err: %d", result);
+            LE_WARN("Unable to start WIFI client; return code: %d", result);
         }
     }
     else
     {
-        LE_INFO("WIFI client already started");
-    }
-
-    // Increment the number of clients calling this start function
-    if (LE_OK == result)
-    {
+        LE_WARN("WIFI client already started");
+        // Increment the number of clients calling this start function
         ClientStartCount++;
+        result = LE_BUSY;
     }
 
     return result;
@@ -660,10 +834,12 @@ le_result_t le_wifiClient_Start
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Stop the WIFI device.
+ * Stops the WIFI device.
  *
- * @return LE_FAULT         The function failed to stop the WIFI module.
- * @return LE_OK            The function succeeded.
+ * @return
+ *      - LE_OK        Function succeeded.
+ *      - LE_FAULT     Function failed.
+ *      - LE_DUPLICATE The WIFI device is already stopped.
  *
  */
 //--------------------------------------------------------------------------------------------------
@@ -674,10 +850,17 @@ le_result_t le_wifiClient_Stop
 {
     le_result_t result = LE_OK;
 
+    if (0 == ClientStartCount)
+    {
+        LE_WARN("The WIFI device is already stopped");
+        return LE_DUPLICATE;
+    }
+
     // Only the last client closes the WIFI module
     if (1 == ClientStartCount)
     {
         pa_wifiClient_ClearAllCredentials();
+        CurrentConnection = NULL;
 
         result = pa_wifiClient_Stop();
         if (LE_OK != result)
@@ -700,12 +883,13 @@ le_result_t le_wifiClient_Stop
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Start scanning for WiFi access points
- * Will result in event LE_WIFICLIENT_EVENT_SCAN_DONE when the scan results are available or
- * event EVENT_SCAN_FAILED if there was an error while scanning.
+ * Start Scanning for WiFi Access points
+ * Will result in event LE_WIFICLIENT_EVENT_SCAN_DONE when the scan results are available.
  *
- * @return LE_FAULT         Function failed.
- * @return LE_OK            Function succeeded.
+ * @return
+ *      - LE_OK     Function succeeded.
+ *      - LE_FAULT  Function failed.
+ *      - LE_BUSY   Scan already running.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_Scan
@@ -732,14 +916,13 @@ le_result_t le_wifiClient_Scan
     }
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
- * Get the first WiFi access point found.
- * It returns the first discovered access point.
+ * Get the first WiFi Access Point found.
  *
- * @return WiFi access point reference if ok.
- * @return NULL if no access point reference available.
+ * @return
+ *      - WiFi  Access Point reference if ok.
+ *      - NULL  If no Access Point reference available.
  */
 //--------------------------------------------------------------------------------------------------
 le_wifiClient_AccessPointRef_t le_wifiClient_GetFirstAccessPoint
@@ -782,15 +965,15 @@ le_wifiClient_AccessPointRef_t le_wifiClient_GetFirstAccessPoint
     }
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * Get the next WiFi Access Point.
  * Will return the Access Points in the order of found.
  * This function must be called in the same context as the GetFirstAccessPoint
  *
- * @return WiFi Access Point reference if ok.
- * @return NULL if no Access Point reference available.
+ * @return
+ *      - WiFi  Access Point reference if ok.
+ *      - NULL  If no Access Point reference available.
 */
 //--------------------------------------------------------------------------------------------------
 le_wifiClient_AccessPointRef_t le_wifiClient_GetNextAccessPoint
@@ -839,14 +1022,15 @@ le_wifiClient_AccessPointRef_t le_wifiClient_GetNextAccessPoint
     }
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
- * Get the signal strength of the Access Point
+ * Get the signal strength of the AccessPoint
  *
  * @return
- *  - signal strength in dBm. Example -30 = -30dBm
- *  - if no signal available it will return OxFFFF
+ *      - Signal strength in dBm. Example -30 = -30dBm
+ *      - If no signal available it will return LE_WIFICLIENT_NO_SIGNAL_STRENGTH
+ *
+ * @note The function returns the signal strength as reported at the time of the scan.
  */
 //--------------------------------------------------------------------------------------------------
 int16_t le_wifiClient_GetSignalStrength
@@ -862,7 +1046,7 @@ int16_t le_wifiClient_GetSignalStrength
     if (NULL == apPtr)
     {
         LE_ERROR("Invalid access point reference.");
-        return SIGNAL_STRENGTH_DEFAULT;
+        return LE_WIFICLIENT_NO_SIGNAL_STRENGTH;
     }
 
     return apPtr->accessPoint.signalStrength;
@@ -870,12 +1054,13 @@ int16_t le_wifiClient_GetSignalStrength
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Get the BSSID of the AccessPoint
+ * Get the Basic Service set identifier (BSSID) of the AccessPoint
  *
- * @return LE_FAULT         Function failed.
- * @return LE_BAD_PARAMETER Some parameter is invalid.
- * @return LE_OVERFLOW      bssid buffer is too small to contain the BSSID
- * @return LE_OK            Function succeeded.
+ * @return
+ *         LE_OK            Function succeeded.
+ *         LE_FAULT         Function failed.
+ *         LE_BAD_PARAMETER Invalid parameter.
+ *         LE_OVERFLOW      bssid buffer is too small to contain the BSSID.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_GetBssid
@@ -919,12 +1104,14 @@ le_result_t le_wifiClient_GetBssid
 //--------------------------------------------------------------------------------------------------
 /**
  * Get the Service set identification (SSID) of the AccessPoint
- * @note that the SSID does not have to be human readable ASCII values, but often has.
  *
- * @return LE_FAULT         Function failed.
- * @return LE_BAD_PARAMETER Some parameter is invalid.
- * @return LE_OVERFLOW      ssid buffer is too small to contain the SSID
- * @return LE_OK            Function succeeded.
+ * @return
+ *        LE_OK            Function succeeded.
+ *        LE_FAULT         Function failed.
+ *        LE_BAD_PARAMETER Invalid parameter.
+ *        LE_OVERFLOW      ssid buffer is too small to contain the SSID.
+ *
+ * @note The SSID does not have to be human readable ASCII values, but often is.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_GetSsid
@@ -958,7 +1145,7 @@ le_result_t le_wifiClient_GetSsid
     }
 
     if (*ssidNumElementsPtr < apPtr->accessPoint.ssidLength) {
-        LE_ERROR("SSID buffer length (%d) is too small to contain SSID of length (%d)",
+        LE_ERROR("SSID buffer length (%zu) is too small to contain SSID of length (%d)",
                  *ssidNumElementsPtr, apPtr->accessPoint.ssidLength);
         return LE_OVERFLOW;
     }
@@ -974,15 +1161,38 @@ le_result_t le_wifiClient_GetSsid
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Set the passphrase used to generate the PSK.
+ * Get the currently selected connection to be established. The output will be Null if none is
+ * selected
  *
- * @note This is one way to authenticate against the access point. The other one is provided by the
- * le_wifiClient_SetPreSharedKey() function. Both ways are exclusive and are effective only when used
- * with WPA-personal authentication.
+ * @return
+ *      - LE_OK            Function succeeded.
+ *      - LE_FAULT         Function failed.
+ */
+//--------------------------------------------------------------------------------------------------
+void le_wifiClient_GetCurrentConnection
+(
+    le_wifiClient_AccessPointRef_t *apRef  ///< [OUT] currently selected connection's AP reference
+)
+{
+    LE_DEBUG("AP reference of currently selected connection: %p", CurrentConnection);
+    if (!apRef)
+    {
+        return;
+    }
+    *apRef = CurrentConnection;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set the passphrase used to generate the PSK.
  *
- * @return LE_BAD_PARAMETER Parameter is invalid.
- * @return LE_OK            Function succeeded.
+ * @return
+ *      - LE_OK            Function succeeded.
+ *      - LE_FAULT         Function failed.
+ *      - LE_BAD_PARAMETER Invalid parameter.
  *
+ * @note The difference between le_wifiClient_SetPreSharedKey() and this function
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_SetPassphrase
@@ -1014,18 +1224,18 @@ le_result_t le_wifiClient_SetPassphrase
     return result;
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
- * Set the pre-shared key (PSK).
+ * Set the Pre Shared Key, PSK.
+ *
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_FAULT          Function failed.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
  *
  * @note This is one way to authenticate against the access point. The other one is provided by the
  * le_wifiClient_SetPassPhrase() function. Both ways are exclusive and are effective only when used
  * with WPA-personal authentication.
- *
- * @return LE_BAD_PARAMETER Parameter is invalid.
- * @return LE_OK            Function succeeded.
- *
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_SetPreSharedKey
@@ -1061,13 +1271,13 @@ le_result_t le_wifiClient_SetPreSharedKey
  * This function specifies whether the target Access Point is hiding its presence from clients or
  * not. When an Access Point is hidden, it cannot be discovered by a scan process.
  *
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ *
  * @note By default, this attribute is not set which means that the client is unable to connect to
  * a hidden access point. When enabled, the client will be able to connect to the access point
  * whether it is hidden or not.
- *
- * @return LE_BAD_PARAMETER Parameter is invalid.
- * @return LE_OK            Function succeeded.
- *
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_SetHiddenNetworkAttribute
@@ -1092,16 +1302,15 @@ le_result_t le_wifiClient_SetHiddenNetworkAttribute
     return LE_OK;
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * WPA-Enterprise requires a username and password to authenticate.
  * This function sets these parameters.
  *
- * @return LE_FAULT         Function failed.
- * @return LE_BAD_PARAMETER Parameter is invalid.
- * @return LE_OK            Function succeeded.
- *
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_FAULT          Function failed.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_SetUserCredentials
@@ -1136,13 +1345,13 @@ le_result_t le_wifiClient_SetUserCredentials
     return result;
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * Set the WEP key (WEP)
  *
- * @return LE_FAULT  The function failed.
- * @return LE_OK     The function succeed.
+ * @return
+ *      - LE_OK     Function succeeded.
+ *      - LE_FAULT  Function failed.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_SetWepKey
@@ -1173,15 +1382,14 @@ le_result_t le_wifiClient_SetWepKey
     return result;
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
- * Set the security mode for connection
- *
- * @return LE_FAULT         Function failed.
- * @return LE_BAD_PARAMETER Parameter is invalid.
- * @return LE_OK            Function succeeded.
+ * Set the security protocol for connection
  *
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_FAULT          Function failed.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_SetSecurityProtocol
@@ -1205,16 +1413,16 @@ le_result_t le_wifiClient_SetSecurityProtocol
     return pa_wifiClient_SetSecurityProtocol(securityProtocol);
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * This function creates a reference to an Access Point given its SSID.
  * If an Access Point is hidden, it will not show up in the scan. So, its SSID must be known
  * in advance in order to create a reference.
  *
- * @note This function fails if called while scan is running.
+ * @return
+ *      - AccessPoint reference to the current Access Point.
  *
- * @return Access Point reference to the current
+ * @note This function fails if called while scan is running.
  */
 //--------------------------------------------------------------------------------------------------
 le_wifiClient_AccessPointRef_t le_wifiClient_Create
@@ -1253,7 +1461,7 @@ le_wifiClient_AccessPointRef_t le_wifiClient_Create
         {
             createdAccessPointPtr->foundInLatestScan = false;
 
-            createdAccessPointPtr->accessPoint.signalStrength = SIGNAL_STRENGTH_DEFAULT;
+            createdAccessPointPtr->accessPoint.signalStrength = LE_WIFICLIENT_NO_SIGNAL_STRENGTH;
             createdAccessPointPtr->accessPoint.ssidLength = ssidNumElements;
             memcpy(&createdAccessPointPtr->accessPoint.ssidBytes[0],
                 ssidPtr,
@@ -1279,15 +1487,16 @@ le_wifiClient_AccessPointRef_t le_wifiClient_Create
     return returnedRef;
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
- * Deletes an apRef.
+ * Deletes an accessPointRef.
+ *
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ *      - LE_BUSY           Function called during scan.
  *
  * @note The handle becomes invalid after it has been deleted.
- * @return LE_BAD_PARAMETER apRef was not found.
- * @return LE_BUSY          Function called during scan.
- * @return LE_OK            Function succeeded.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_Delete
@@ -1323,9 +1532,12 @@ le_result_t le_wifiClient_Delete
  * Connect to the WiFi Access Point.
  * All authentication must be set prior to calling this function.
  *
- * @return LE_FAULT         Function failed.
- * @return LE_BAD_PARAMETER Parameter is invalid.
- * @return LE_OK            Function succeeded.
+ * @return
+ *      - LE_OK             Function succeeded.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ *      - LE_DUPLICATE      Duplicated request.
+ *      - LE_TIMEOUT        Connection request time out.
+ *      - LE_FAULT          The function failed.
  *
  * @note For PSK credentials see le_wifiClient_SetPassphrase() or le_wifiClient_SetPreSharedKey() .
  * @note For WPA-Enterprise credentials see le_wifiClient_SetUserCredentials()
@@ -1340,16 +1552,19 @@ le_result_t le_wifiClient_Connect
 {
     le_result_t         result = LE_BAD_PARAMETER;
     FoundAccessPoint_t *apPtr  = le_ref_Lookup(ScanApRefMap, apRef);
+    uint16_t ssidLen;
 
     // verify le_ref_Lookup
     if (NULL !=  apPtr)
     {
-        LE_DEBUG("SSID length %d | SSID: \"%.*s\"",
-            apPtr->accessPoint.ssidLength,
-            apPtr->accessPoint.ssidLength,
-            (char *)apPtr->accessPoint.ssidBytes);
-
-        result = pa_wifiClient_Connect(apPtr->accessPoint.ssidBytes, apPtr->accessPoint.ssidLength);
+        ssidLen = apPtr->accessPoint.ssidLength;
+        LE_DEBUG("SSID length %d | SSID: \"%.*s\"", ssidLen, ssidLen,
+                 (char *)apPtr->accessPoint.ssidBytes);
+        result = pa_wifiClient_Connect(apPtr->accessPoint.ssidBytes, ssidLen);
+        if (LE_OK == result)
+        {
+            CurrentConnection = apRef;
+        }
     }
     return result;
 }
@@ -1357,49 +1572,842 @@ le_result_t le_wifiClient_Connect
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Disconnect from the WiFi Access Point.
+ * Disconnect from the current connected WiFi Access Point.
  *
- * @return LE_FAULT         Function failed.
- * @return LE_OK            Function succeeded.
+ * @return
+ *      - LE_OK     Function succeeded.
+ *      - LE_FAULT  Function failed.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t le_wifiClient_Disconnect
 (
+    void
 )
 {
     LE_DEBUG("Disconnect");
+    CurrentConnection = NULL;
     return pa_wifiClient_Disconnect();
 }
 
 
 //--------------------------------------------------------------------------------------------------
 /**
- *  WiFi Client COMPONENT Init
+ * This function seeks to load the WEP key of a given SSID from the known secured store path, which
+ * has been configured there earlier via the le_wifiClient_ConfigureWep() API.
+ *
+ * @return:
+ *     - LE_OK upon the success in retrieving the WEP key; LE_FAULT otherwise
  */
 //--------------------------------------------------------------------------------------------------
-void le_wifiClient_Init
+static le_result_t WifiClient_LoadCfg_Wep
 (
-    void
+    const char *ssidPtr,
+    uint8_t *wepKeyPtr,
+    size_t *wepKeyPtrSize
 )
 {
-    LE_DEBUG("WiFi client service starting...");
-
-    pa_wifiClient_Init();
+    le_result_t ret;
+    char secStorePath[LE_CFG_STR_LEN_BYTES] = {0};
+
+    snprintf(secStorePath, sizeof(secStorePath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssidPtr, SECSTORE_NODE_WEP_KEY);
+    *wepKeyPtrSize = LE_WIFIDEFS_MAX_WEPKEY_LENGTH;
+    ret = le_secStore_Read(secStorePath, wepKeyPtr, wepKeyPtrSize);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to read WEP key from secStore path %s for SSID %s; retcode %d",
+                 secStorePath, ssidPtr, ret);
+        wepKeyPtr[0] = '\0';
+        *wepKeyPtrSize = 0;
+        return LE_FAULT;
+    }
 
-    // Create the Access Point object pool.
-    AccessPointPool = le_mem_CreatePool("le_wifi_FoundAccessPointPool", sizeof(FoundAccessPoint_t));
-    le_mem_ExpandPool(AccessPointPool, INIT_AP_COUNT);
+    LE_DEBUG("Succeeded to read WEP key from secStore path %s for SSID %s", secStorePath,
+             ssidPtr);
+    return LE_OK;
+}
 
-    // Create the Safe Reference Map to use for FoundAccessPoint_t object Safe References.
-    ScanApRefMap = le_ref_CreateMap("le_wifiClient_AccessPoints", INIT_AP_COUNT);
 
-    // Create an event Id for new WiFi Events
-    NewWifiEventId = le_event_CreateId("WifiClientEvent", sizeof(le_wifiClient_Event_t));
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function seeks to load the WPA EAP configs of a given SSID from the known secured store
+ * path, which have been configured there earlier via the le_wifiClient_ConfigureEAP() API. These
+ * include the user name and password.
+ *
+ * @return:
+ *     - LE_OK upon the success in retrieving both the user name and password; LE_FAULT otherwise
+ */
+//--------------------------------------------------------------------------------------------------
+static le_result_t WifiClient_LoadCfg_WpaEap
+(
+    const char *ssidPtr,
+    le_wifiClient_SecurityProtocol_t secProtocol,
+    uint8_t *usernamePtr,
+    size_t *usernamePtrSize,
+    uint8_t *passwordPtr,
+    size_t *passwordPtrSize
+)
+{
+    le_result_t ret;
+    char secStorePath[LE_CFG_STR_LEN_BYTES] = {0};
+
+    snprintf(secStorePath, sizeof(secStorePath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssidPtr, SECSTORE_NODE_USERPWD);
+    *passwordPtrSize = LE_WIFIDEFS_MAX_PASSWORD_LENGTH;
+    ret = le_secStore_Read(secStorePath, passwordPtr, passwordPtrSize);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to read EAP password from secStore path %s for SSID %s; retcode %d",
+                 secStorePath, ssidPtr, ret);
+        usernamePtr[0] = '\0';
+        *usernamePtrSize = 0;
+        passwordPtr[0] = '\0';
+        *passwordPtrSize = 0;
+        return LE_FAULT;
+    }
 
-    // register for events from PA.
-    pa_wifiClient_AddEventHandler(PaEventHandler, NULL);
+    snprintf(secStorePath, sizeof(secStorePath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssidPtr, SECSTORE_NODE_USERNAME);
+    *usernamePtrSize = LE_WIFIDEFS_MAX_USERNAME_LENGTH;
+    ret = le_secStore_Read(secStorePath, usernamePtr, usernamePtrSize);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to read EAP username from secStore path %s for SSID %s; retcode %d",
+                 secStorePath, ssidPtr, ret);
+        usernamePtr[0] = '\0';
+        *usernamePtrSize = 0;
+        passwordPtr[0] = '\0';
+        *passwordPtrSize = 0;
+        return LE_FAULT;
+    }
 
-    // Add a handler to handle the close
-    le_msg_AddServiceCloseHandler(le_wifiClient_GetServiceRef(), CloseSessionEventHandler, NULL);
+    LE_DEBUG("Succeeded to read EAP username & password from secStore for SSID %s", ssidPtr);
+    return LE_OK;
 }
 
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function seeks to set the retrieved WPA passphrase or PSK of a given SSID into wifiClient
+ * before le_wifiClient_Connect() can be attempted. Either a passphrase or a pre-shared key needs
+ * to be set before connecting.
+ *
+ * @return:
+ *     - LE_OK upon the success in setting the given WPA passphrase or pre-shared key into
+ *       wifiClient; LE_FAULT otherwise
+ */
+//--------------------------------------------------------------------------------------------------
+static le_result_t WifiClient_SetCfg_WpaPsk
+(
+    le_wifiClient_AccessPointRef_t *apRefPtr,
+    const char *ssidPtr,
+    uint8_t *passPhrasePtr,
+    size_t passPhrasePtrSize,
+    uint8_t *preSharedKeyPtr,
+    size_t preSharedKeyPtrSize
+)
+{
+    if (passPhrasePtrSize > 0)
+    {
+        // As passPhrasePtr might not have been null terminated, null-terminate it before passing
+        // it to le_wifiClient_SetPassphrase() as a char string. It should have enough space
+        // to accommodate this 1 more character.
+        passPhrasePtr[passPhrasePtrSize] = '\0';
+        if (LE_OK != le_wifiClient_SetPassphrase(*apRefPtr, (const char *)passPhrasePtr))
+        {
+            LE_ERROR("Failed to config passphrase to start connection over SSID %s", ssidPtr);
+            return LE_FAULT;
+        }
+        return LE_OK;
+    }
+
+    if (preSharedKeyPtrSize > 0)
+    {
+        // As preSharedKeyPtr might not have been null terminated, null-terminate it before passing
+        // it to le_wifiClient_SetPreSharedKey() as a char string. It should have enough space
+        // to accommodate this 1 more character.
+        preSharedKeyPtr[preSharedKeyPtrSize] = '\0';
+        if (LE_OK != le_wifiClient_SetPreSharedKey(*apRefPtr, (const char *)preSharedKeyPtr))
+        {
+            LE_ERROR("Failed to config pre-shared key to start connection over SSID %s", ssidPtr);
+            return LE_FAULT;
+        }
+        return LE_OK;
+    }
+
+    LE_ERROR("Failed to set WPA parameters to start connection over SSID %s", ssidPtr);
+    return LE_FAULT;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function seeks to load the WPA config of a given SSID from the known secured store path,
+ * which has been configured there earlier via the le_wifiClient_ConfigurePsk() API. It'll try to
+ * retrieve passphrase 1st. If no valid one can be found, then it proceeds to try retrieving PSK
+ * config.
+ *
+ * @return:
+ *     - LE_OK upon the success in retrieving a WPA passphrase or pre-shared key; LE_FAULT otherwise
+ */
+//--------------------------------------------------------------------------------------------------
+static le_result_t WifiClient_LoadCfg_WpaPsk
+(
+    const char *ssidPtr,
+    le_wifiClient_SecurityProtocol_t secProtocol,
+    uint8_t *passPhrasePtr,
+    size_t *passPhrasePtrSize,
+    uint8_t *preSharedKeyPtr,
+    size_t *preSharedKeyPtrSize
+)
+{
+    le_result_t ret;
+    char secStorePath[LE_CFG_STR_LEN_BYTES] = {0};
+
+    // Try to load passphrase 1st. If no valid one is found, don't quit yet but try loading a
+    // pre-shared key
+    snprintf(secStorePath, sizeof(secStorePath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssidPtr, SECSTORE_NODE_PASSPHRASE);
+    *passPhrasePtrSize = LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH;
+    ret = le_secStore_Read(secStorePath, passPhrasePtr, passPhrasePtrSize);
+    if ((ret == LE_OK) && (*passPhrasePtrSize > 0))
+    {
+        LE_DEBUG("Succeeded to read passphrase from secStore path %s for SSID %s", secStorePath,
+                 ssidPtr);
+        return LE_OK;
+    }
+
+    LE_WARN("Failed to read passphrase from secStore path %s for SSID %s; retcode %d",
+             secStorePath, ssidPtr, ret);
+    LE_DEBUG("Failed to retrieve a valid WPA passphrase; try pre-shared key now");
+    *passPhrasePtrSize = 0;
+
+    // Try to load pre-shared key as it has failed to load passphrase
+    snprintf(secStorePath, sizeof(secStorePath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssidPtr, SECSTORE_NODE_PSK);
+    *preSharedKeyPtrSize = LE_WIFIDEFS_MAX_PSK_LENGTH;
+    ret = le_secStore_Read(secStorePath, preSharedKeyPtr, preSharedKeyPtrSize);
+    if ((ret != LE_OK) || (*preSharedKeyPtrSize == 0))
+    {
+        LE_ERROR("Failed to read pre-shared key from secStore path %s for SSID %s; retcode %d",
+                 secStorePath, ssidPtr, ret);
+        *preSharedKeyPtrSize = 0;
+        return LE_FAULT;
+    }
+
+    LE_DEBUG("Succeeded to read pre-shared key from secStore path %s for SSID %s", secStorePath,
+             ssidPtr);
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function seeks to load the security configs of a given SSID from the known secured store
+ * paths and set them into wifiClient for use. It takes care of the various security protocols
+ * supported and the their necessary config parameters. Before setting the valid security configs
+ * into use, it creates a local AP reference for the given SSID, into which these security
+ * configs will be set before the Wifi client proceeds with le_wifiClient_Connect() to  establish
+ * a connection over this SSID.
+ *
+ * @return:
+ *     - LE_OK upon the success in retrieving the necessary security configs and setting them into
+ *       place for proceeding with connecting; LE_FAULT otherwise
+ */
+//--------------------------------------------------------------------------------------------------
+static le_result_t WifiClient_LoadSecurityConfigs
+(
+    const char *ssidPtr,
+    le_wifiClient_AccessPointRef_t *apRefPtr,
+    le_wifiClient_SecurityProtocol_t secProtocol
+)
+{
+    le_result_t ret;
+
+    // Use unions for these strings to save memory space, as they're mutually exclusive
+    union {
+        uint8_t passphrase[LE_WIFIDEFS_MAX_PASSPHRASE_BYTES];
+        uint8_t username[LE_WIFIDEFS_MAX_USERNAME_BYTES];
+        uint8_t wepKey[LE_WIFIDEFS_MAX_WEPKEY_BYTES];
+    } u1;
+    union {
+        uint8_t preSharedKey[LE_WIFIDEFS_MAX_PSK_BYTES];
+        uint8_t password[LE_WIFIDEFS_MAX_PASSWORD_BYTES];
+    } u2;
+    size_t size1 = 0, size2 = 0;
+
+    memset(&u1, 0x0, sizeof(u1));
+    memset(&u2, 0x0, sizeof(u2));
+
+    // Load security parameters from configs
+    switch (secProtocol)
+    {
+        case LE_WIFICLIENT_SECURITY_NONE:
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WEP:
+            ret = WifiClient_LoadCfg_Wep(ssidPtr, u1.wepKey, &size1);
+            if (ret != LE_OK)
+            {
+                return ret;
+            }
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL:
+        case LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL:
+            ret = WifiClient_LoadCfg_WpaPsk(ssidPtr, secProtocol, u1.passphrase, &size1,
+                                            u2.preSharedKey, &size2);
+            if (ret != LE_OK)
+            {
+                return ret;
+            }
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE:
+        case LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE:
+            ret = WifiClient_LoadCfg_WpaEap(ssidPtr, secProtocol, u1.username, &size1,
+                                            u2.password, &size2);
+            if (ret != LE_OK)
+            {
+                return ret;
+            }
+            break;
+
+        default:
+            LE_ERROR("Invalid security protocol %d", secProtocol);
+            return LE_FAULT;
+    }
+
+    LE_DEBUG("Successfully retrieved security parameters for protocol %d over SSID %s",
+             secProtocol, ssidPtr);
+
+    // Create the Access Point to connect to
+    *apRefPtr = le_wifiClient_Create((const uint8_t *)ssidPtr, strlen(ssidPtr));
+    if (!*apRefPtr)
+    {
+        LE_ERROR("Failed to create Access Point to start connection over SSID %s", ssidPtr);
+        return LE_FAULT;
+    }
+
+    if (LE_OK != le_wifiClient_SetSecurityProtocol(*apRefPtr, secProtocol))
+    {
+        LE_ERROR("Failed to set security protocol to start connection over SSID %s", ssidPtr);
+        (void)le_wifiClient_Delete(*apRefPtr);
+        *apRefPtr = 0;
+        return LE_FAULT;
+    }
+
+    // Set security parameters into le_wifiClient for use
+    switch (secProtocol)
+    {
+        case LE_WIFICLIENT_SECURITY_NONE:
+            ret = LE_OK;
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WEP:
+            // As wepKey might not have been null terminated, null-terminate it before passing
+            // it to le_wifiClient_SetWepKey() as a char string. It should have enough space
+            // to accommodate this 1 more character.
+            u1.wepKey[size1] = '\0';
+            ret = le_wifiClient_SetWepKey(*apRefPtr, (const char *)u1.wepKey);
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL:
+        case LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL:
+            ret = WifiClient_SetCfg_WpaPsk(apRefPtr, ssidPtr, u1.passphrase, size1,
+                                           u2.preSharedKey, size2);
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE:
+        case LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE:
+            // As they might not have been null terminated, null-terminate the 2 uint8_t arrays
+            // before passing them to le_wifiClient_SetUserCredentials() as char strings. They
+            // should have enough space to accommodate this 1 more character.
+            u1.username[size1] = '\0';
+            u2.password[size2] = '\0';
+            ret = le_wifiClient_SetUserCredentials(*apRefPtr, (const char *)u1.username,
+                                                   (const char *)u2.password);
+            break;
+
+        default:
+            break;
+    }
+
+    if (ret != LE_OK)
+    {
+        (void)le_wifiClient_Delete(*apRefPtr);
+        *apRefPtr = 0;
+        return ret;
+    }
+    LE_INFO("Succeeded to set into wifiClient security parameters of protocol %d for SSID %s",
+            secProtocol, ssidPtr);
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Load the given SSID's configurations as it is selected as the connection to get established,
+ * after creating for it an AP reference
+ *
+ * @return
+ *      - LE_OK     Function succeeded.
+ *      - LE_FAULT  Function failed.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiClient_LoadSsid
+(
+    const uint8_t *ssidPtr,                       ///< [IN] SSID which configs are to be installed
+    size_t ssidPtrSize,                           ///< [IN] Length of the SSID in octets
+    le_wifiClient_AccessPointRef_t *apRefPtr      ///< [OUT] reference to be created
+)
+{
+    // Retrieve data from config tree
+    char configPath[LE_CFG_STR_LEN_BYTES] = {0};
+    char ssid[LE_WIFIDEFS_MAX_SSID_BYTES] = {0};
+    le_cfg_IteratorRef_t cfg;
+    le_wifiClient_SecurityProtocol_t secProtocol;
+    le_result_t ret;
+    bool is_hidden = false;
+
+    if (!apRefPtr)
+    {
+        LE_ERROR("Invalid AP reference input for setting configs");
+        return LE_BAD_PARAMETER;
+    }
+
+    *apRefPtr = 0;
+
+    if (!ssidPtr || (ssidPtrSize == 0))
+    {
+        LE_ERROR("Invalid SSID input for setting configs");
+        return LE_BAD_PARAMETER;
+    }
+
+    // Copy the ssidPtr input over, in case it's not null terminated and has no extra space behind
+    // to set it there
+    memcpy(ssid, ssidPtr, ssidPtrSize);
+
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", CFG_TREE_ROOT_DIR, CFG_PATH_WIFI, ssid);
+    cfg = le_cfg_CreateReadTxn(configPath);
+    if (!cfg)
+    {
+        LE_ERROR("Failed to get configs of SSID %s", ssid);
+        return LE_BAD_PARAMETER;
+    }
+
+    // Security protocol
+    if (!le_cfg_NodeExists(cfg, CFG_NODE_SECPROTOCOL))
+    {
+        LE_DEBUG("No wifi security protocol set at %s/%s", configPath, CFG_NODE_SECPROTOCOL);
+        secProtocol = LE_WIFICLIENT_SECURITY_NONE;
+    }
+    else
+    {
+        secProtocol = le_cfg_GetInt(cfg, CFG_NODE_SECPROTOCOL,
+                                    LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL);
+    }
+    ret = WifiClient_LoadSecurityConfigs(ssid, apRefPtr, secProtocol);
+    if (ret != LE_OK)
+    {
+        le_cfg_CancelTxn(cfg);
+        return ret;
+    }
+
+    // Hidden SSID or not
+    if (le_cfg_NodeExists(cfg, CFG_NODE_HIDDEN_SSID))
+    {
+        is_hidden = le_cfg_GetBool(cfg, CFG_NODE_HIDDEN_SSID, false);
+    }
+
+    le_cfg_CancelTxn(cfg);
+
+    if (is_hidden && (LE_OK != le_wifiClient_SetHiddenNetworkAttribute(*apRefPtr, true)))
+    {
+        LE_ERROR("Failed to set as hidden SSID %s with AP reference %p", ssid, *apRefPtr);
+        (void)le_wifiClient_Delete(*apRefPtr);
+        *apRefPtr = 0;
+        return LE_FAULT;
+    }
+
+    LE_INFO("Succeeded to create AP reference %p for SSID %s", *apRefPtr, ssid);
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Configure the given SSID to use WEP and the given WEP key in the respective input argument.
+ *
+ * @return
+ *      - LE_OK     Succeeded to configure the given WEP key for the given SSID.
+ *      - LE_FAULT  Failed to configure.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiClient_ConfigureWep
+(
+    const uint8_t *ssidPtr,    ///< [IN] SSID which configs are to be installed
+    size_t ssidPtrSize,        ///< [IN] Length of the SSID in octets
+    const uint8_t *wepKeyPtr,  ///< [IN] WEP key used for this SSID
+    size_t wepKeyPtrSize       ///< [IN] Length of the WEP key in octets
+)
+{
+    le_result_t ret;
+    char configPath[LE_CFG_STR_LEN_BYTES] = {0};
+    char ssid[LE_WIFIDEFS_MAX_SSID_BYTES] = {0};
+    le_cfg_IteratorRef_t cfg;
+
+    if (!ssidPtr || (ssidPtrSize == 0))
+    {
+        LE_ERROR("Invalid inputs: SSID size %d", (int)ssidPtrSize);
+        return LE_BAD_PARAMETER;
+    }
+
+    if (!wepKeyPtr)
+    {
+        LE_ERROR("Invalid WEP key");
+        return LE_BAD_PARAMETER;
+    }
+
+    // Copy the ssidPtr input over, in case it's not null terminated and has no extra space behind
+    // to set it there
+    memcpy(ssid, ssidPtr, ssidPtrSize);
+
+    // Write secProtocol into config tree
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", CFG_TREE_ROOT_DIR, CFG_PATH_WIFI, ssid);
+    cfg = le_cfg_CreateWriteTxn(configPath);
+    le_cfg_SetInt(cfg, CFG_NODE_SECPROTOCOL, LE_WIFICLIENT_SECURITY_WEP);
+    le_cfg_CommitTxn(cfg);
+
+    // Write WEP key into secStore
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssid, SECSTORE_NODE_WEP_KEY);
+    ret = le_secStore_Write(configPath, wepKeyPtr, wepKeyPtrSize);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to write WEP key into secStore path %s for SSID %s; retcode %d",
+                 configPath, ssid, ret);
+        return LE_FAULT;
+    }
+
+    LE_INFO("Succeeded to write WEP configs for SSID %s into secStore", ssid);
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Configure the given SSID to use PSK and the given pass-phrase or pre-shared key in the
+ * respective input arguments. The protocol input is mandatory and has to be set to either
+ * LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL or LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL.
+ * Besides, it's mandatory to have at least one of the pass-phrase and pre-shared key supplied. If
+ * both are provided as input, the pass-phrase has precedence and will be used. But it fails to
+ * authenticate, a second attempt using the provided pre-shared key will not be done.
+ *
+ * @return
+ *      - LE_OK     Succeeded to configure the given passphrase or pre-shared key for the given
+ *                  SSID.
+ *      - LE_FAULT  Failed to configure.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiClient_ConfigurePsk
+(
+    const uint8_t *ssidPtr,                     ///< [IN] SSID which configs are to be installed
+    size_t ssidPtrSize,                         ///< [IN] Length of the SSID in octets
+    le_wifiClient_SecurityProtocol_t protocol,  ///< [IN] security protocol WPA-PSK or WPA2-PSK
+    const uint8_t *passPhrasePtr,               ///< [IN] passphrase used for this SSID
+    size_t passPhrasePtrSize,                   ///< [IN] Length of the passphrase in octets
+    const uint8_t *pskPtr,                      ///< [IN] pre-shared key used for this SSID
+    size_t pskPtrSize                           ///< [IN] Length of the pre-shared key in octets
+)
+{
+    le_result_t ret1 = LE_OK, ret2 = LE_OK;
+    char configPath[LE_CFG_STR_LEN_BYTES] = {0};
+    char ssid[LE_WIFIDEFS_MAX_SSID_BYTES] = {0};
+    le_cfg_IteratorRef_t cfg;
+
+    if ((protocol != LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL) &&
+        (protocol != LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL))
+    {
+        LE_ERROR("Incorrect protocol type %d for setting PSK", protocol);
+        return LE_BAD_PARAMETER;
+    }
+    if (!ssidPtr || (ssidPtrSize == 0))
+    {
+        LE_ERROR("Invalid inputs: SSID size %d", (int)ssidPtrSize);
+        return LE_BAD_PARAMETER;
+    }
+
+    if (!passPhrasePtr && !pskPtr)
+    {
+        LE_ERROR("Invalid input: both given passphrase and pre-shared key are null");
+        return LE_BAD_PARAMETER;
+    }
+
+    // Copy the ssidPtr input over, in case it's not null terminated and has no extra space behind
+    // to set it there
+    memcpy(ssid, ssidPtr, ssidPtrSize);
+
+    // Write secProtocol into config tree
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", CFG_TREE_ROOT_DIR, CFG_PATH_WIFI, ssid);
+    cfg = le_cfg_CreateWriteTxn(configPath);
+    le_cfg_SetInt(cfg, CFG_NODE_SECPROTOCOL, protocol);
+    le_cfg_CommitTxn(cfg);
+
+    // Write passPhrase into secStore
+    if (passPhrasePtr)
+    {
+        if (passPhrasePtrSize > LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH)
+        {
+            LE_ERROR("Invalid input: passphrase's length %d has to be shorter than %d",
+                     (int)passPhrasePtrSize, LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH);
+            ret1 = LE_BAD_PARAMETER;
+        }
+        else if (passPhrasePtrSize < LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH)
+        {
+            LE_ERROR("Invalid input: passphrase's length %d has to be longer than %d",
+                     (int)passPhrasePtrSize, LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH);
+            ret1 = LE_BAD_PARAMETER;
+        }
+        else
+        {
+            snprintf(configPath, sizeof(configPath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+                     ssid, SECSTORE_NODE_PASSPHRASE);
+            ret1 = le_secStore_Write(configPath, passPhrasePtr, passPhrasePtrSize);
+            if (ret1 != LE_OK)
+            {
+                LE_ERROR("Failed to write passphrase into secStore path %s for SSID %s; retcode %d",
+                         configPath, ssid, ret2);
+            }
+            else
+            {
+                LE_DEBUG("Succeeded writing passphrase into secStore");
+            }
+        }
+
+        if (!pskPtr)
+        {
+            return ((ret1 == LE_OK) ? LE_OK : ret1);
+        }
+    }
+
+    if (pskPtr)
+    {
+        if (pskPtrSize > LE_WIFIDEFS_MAX_PSK_LENGTH)
+        {
+            LE_ERROR("Invalid input: pre-shared key's length %d has to be shorter than %d",
+                     (int)pskPtrSize, LE_WIFIDEFS_MAX_PSK_LENGTH);
+            ret2 = LE_BAD_PARAMETER;
+        }
+        else
+        {
+            snprintf(configPath, sizeof(configPath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+                     ssid, SECSTORE_NODE_PSK);
+            ret2 = le_secStore_Write(configPath, pskPtr, pskPtrSize);
+            if (ret2 != LE_OK)
+            {
+                LE_ERROR("Failed to write pre-shared key into secStore path %s for SSID %s; "
+                         "retcode %d", configPath, ssid, ret2);
+            }
+            else
+            {
+                LE_DEBUG("Succeeded to write pre-shared key into secStore");
+            }
+        }
+
+        if (!passPhrasePtr)
+        {
+            return ((ret2 == LE_OK) ? LE_OK : ret2);
+        }
+    }
+
+    if ((ret1 != LE_OK) && (ret2 != LE_OK))
+    {
+        return LE_FAULT;
+    }
+
+    LE_INFO("Succeeded to write PSK configs for SSID %s into secStore", ssid);
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Configure the given SSID to use EAP and the given EAP username and password in the respective
+ * input arguments. The protocol input is mandatory and has to be set to either
+ * LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE or
+ * LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE. Besides, both the username and password inputs
+ * are mandatory.
+ *
+ * @return
+ *      - LE_OK     Succeeded to configure the given EAP username and password for the given
+ *                  SSID.
+ *      - LE_FAULT  Failed to configure.
+ *      - LE_BAD_PARAMETER  Invalid parameter.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiClient_ConfigureEap
+(
+    const uint8_t *ssidPtr,                     ///< [IN] SSID which configs are to be installed
+    size_t ssidPtrSize,                         ///< [IN] Length of the SSID in octets
+    le_wifiClient_SecurityProtocol_t protocol,  ///< [IN] security protocol WPA-EAP or WPA2-EAP
+    const uint8_t *usernamePtr,                 ///< [IN] EAP username used for this SSID
+    size_t usernamePtrSize,                     ///< [IN] Length of the username in octets
+    const uint8_t *passwordPtr,                 ///< [IN] EAP password used for this SSID
+    size_t passwordPtrSize                      ///< [IN] Length of the password in octets
+)
+{
+    le_result_t ret;
+    char configPath[LE_CFG_STR_LEN_BYTES] = {0};
+    char ssid[LE_WIFIDEFS_MAX_SSID_BYTES] = {0};
+    le_cfg_IteratorRef_t cfg;
+
+    if ((protocol != LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE) &&
+        (protocol != LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE))
+    {
+        LE_ERROR("Incorrect protocol type %d for setting EAP", protocol);
+        return LE_BAD_PARAMETER;
+    }
+    if (!ssidPtr || (ssidPtrSize == 0))
+    {
+        LE_ERROR("Invalid inputs: SSID size %d", (int)ssidPtrSize);
+        return LE_BAD_PARAMETER;
+    }
+
+    if (!usernamePtr || !passwordPtr)
+    {
+        LE_ERROR("Invalid input: username %p password %p", usernamePtr, passwordPtr);
+        return LE_BAD_PARAMETER;
+    }
+
+    // Copy the ssidPtr input over, in case it's not null terminated and has no extra space behind
+    // to set it there
+    memcpy(ssid, ssidPtr, ssidPtrSize);
+
+    // Write secProtocol into config tree
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", CFG_TREE_ROOT_DIR, CFG_PATH_WIFI, ssid);
+    cfg = le_cfg_CreateWriteTxn(configPath);
+    le_cfg_SetInt(cfg, CFG_NODE_SECPROTOCOL, protocol);
+    le_cfg_CommitTxn(cfg);
+
+    // Write username & password into secStore
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssid, SECSTORE_NODE_USERNAME);
+    ret = le_secStore_Write(configPath, usernamePtr, usernamePtrSize);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to write username into secStore path %s for SSID %s; retcode %d",
+                 configPath, ssid, ret);
+        return LE_FAULT;
+    }
+
+    snprintf(configPath, sizeof(configPath), "%s/%s/%s", SECSTORE_WIFI_ITEM_ROOT,
+             ssid, SECSTORE_NODE_USERPWD);
+    ret = le_secStore_Write(configPath, passwordPtr, passwordPtrSize);
+    if (ret != LE_OK)
+    {
+        LE_ERROR("Failed to write user password into secStore path %s for SSID %s; retcode %d",
+                 configPath, ssid, ret);
+        return LE_FAULT;
+    }
+
+    LE_INFO("Succeeded to write EAP configs for SSID %s into secStore", ssid);
+    return LE_OK;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Remove and clear Wifi's security configurations to use with the given SSID from the config tree
+ * and secured store. This includes the security protocol and all the username, password,
+ * passphrase, pre-shared key, key, etc., previously configured via le_wifiClient_Configure APIs for
+ * WEP, PSK and EAP.
+ *
+ * @return
+ *      - LE_OK upon success to deconfigure the given SSID's configured user credentials;
+ *        LE_FAULT otherwise
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t le_wifiClient_RemoveSsidSecurityConfigs
+(
+    const uint8_t *ssidPtr,         ///< [IN] SSID which user credentials are to be deconfigured
+    size_t ssidPtrSize              ///< [IN] Length of the SSID in octets
+)
+{
+    le_result_t ret;
+    char ssid[LE_WIFIDEFS_MAX_SSID_BYTES] = {0};
+    char configPath[LE_CFG_STR_LEN_BYTES] = {0};
+    le_cfg_IteratorRef_t cfg;
+
+    if (!ssidPtr || (ssidPtrSize == 0))
+    {
+        LE_ERROR("Invalid inputs: SSID size %d", (int)ssidPtrSize);
+        return LE_BAD_PARAMETER;
+    }
+
+    // Copy the ssidPtr input over, in case it's not null terminated and has no extra space behind
+    // to set it there
+    memcpy(ssid, ssidPtr, ssidPtrSize);
+    snprintf(configPath, sizeof(configPath), "%s/%s", SECSTORE_WIFI_ITEM_ROOT, ssid);
+    ret = le_secStore_Delete(configPath);
+    if (ret == LE_NOT_FOUND)
+    {
+        LE_WARN("Found secStore path %s non-existent to remove", configPath);
+    }
+    else if (ret == LE_OK)
+    {
+        // Clear secProtocol setting on config tree
+        snprintf(configPath, sizeof(configPath), "%s/%s/%s", CFG_TREE_ROOT_DIR, CFG_PATH_WIFI,
+                 ssid);
+        cfg = le_cfg_CreateWriteTxn(configPath);
+        le_cfg_SetInt(cfg, CFG_NODE_SECPROTOCOL, LE_WIFICLIENT_SECURITY_NONE);
+        le_cfg_CommitTxn(cfg);
+        LE_INFO("Succeeded to delete from secStore user credentials for SSID %s", ssid);
+    }
+    else
+    {
+        LE_ERROR("Failed to delete user credentials for SSID %s on secStore path %s; retcode %d",
+                 ssid, configPath, ret);
+    }
+    return ret;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+/**
+ *  WiFi Client COMPONENT Init
+ */
+//--------------------------------------------------------------------------------------------------
+void le_wifiClient_Init
+(
+    void
+)
+{
+    LE_DEBUG("WiFi client service starting...");
+
+    pa_wifiClient_Init();
+
+    // Create the Access Point object pool.
+    AccessPointPool = le_mem_CreatePool("le_wifi_FoundAccessPointPool", sizeof(FoundAccessPoint_t));
+    le_mem_ExpandPool(AccessPointPool, INIT_AP_COUNT);
+
+    // Create the Safe Reference Map to use for FoundAccessPoint_t object Safe References.
+    ScanApRefMap = le_ref_CreateMap("le_wifiClient_AccessPoints", INIT_AP_COUNT);
+
+    // Create an event indication Id for WiFi Events
+    WifiEventIndicationId = le_event_CreateIdWithRefCounting("WifiConnectState");
+    WifiEventPool = le_mem_CreatePool("WifiConnectStatePool", sizeof(le_wifiClient_EventInd_t));
+    // register for events from PA.
+    pa_wifiClient_AddEventIndHandler(PaEventIndicationHandler, NULL);
+
+    // Create an event Id for WiFi Events
+    WifiEventId = le_event_CreateId("WifiClientEvent", sizeof(le_wifiClient_Event_t));
+    // register for events from PA.
+    pa_wifiClient_AddEventHandler(PaEventHandler, NULL);
+
+    // Add a handler to handle the close
+    le_msg_AddServiceCloseHandler(le_wifiClient_GetServiceRef(), CloseSessionEventHandler, NULL);
+}
diff --git a/service/platformAdaptor/ti/pa_wifi_ap_ti.c b/service/platformAdaptor/common/pa_wifi_ap.c
similarity index 64%
rename from service/platformAdaptor/ti/pa_wifi_ap_ti.c
rename to service/platformAdaptor/common/pa_wifi_ap.c
index 580e3c6..37a0626 100644
--- a/service/platformAdaptor/ti/pa_wifi_ap_ti.c
+++ b/service/platformAdaptor/common/pa_wifi_ap.c
@@ -12,30 +12,29 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include "legato.h"
-
 #include "interfaces.h"
-
 #include "pa_wifi_ap.h"
-#include "stdio.h"
 
 // Set of commands to drive the WiFi features.
-#define COMMAND_WIFI_HW_START        "wlan0 WIFI_START"
-#define COMMAND_WIFI_HW_STOP         "wlan0 WIFI_STOP"
-#define COMMAND_WIFI_WLAN_UP         "wlan0 WIFI_WLAN_UP"
-#define COMMAND_WIFI_SET_EVENT       "wlan0 WIFI_SET_EVENT"
-#define COMMAND_WIFIAP_HOSTAPD_START "wlan0 WIFIAP_HOSTAPD_START"
-#define COMMAND_WIFIAP_HOSTAPD_STOP  "wlan0 WIFIAP_HOSTAPD_STOP"
+#define COMMAND_WIFI_HW_START        "WIFI_START"
+#define COMMAND_WIFI_HW_STOP         "WIFI_STOP"
+#define COMMAND_WIFI_SET_EVENT       "WIFI_SET_EVENT"
+#define COMMAND_WIFI_UNSET_EVENT     "WIFI_UNSET_EVENT"
+#define COMMAND_WIFIAP_HOSTAPD_START "WIFIAP_HOSTAPD_START"
+#define COMMAND_WIFIAP_HOSTAPD_STOP  "WIFIAP_HOSTAPD_STOP"
+#define COMMAND_WIFIAP_WLAN_UP       "WIFIAP_WLAN_UP"
 
-// iptables rule to allow/disallow the DHCP port on wlan0
-#define COMMAND_IPTABLE_DHCP_WLAN0   "INPUT -i wlan0 -p udp -m udp " \
-                                     "--sport 67:68 --dport 67:68 -j ACCEPT"
+// iptables rule to allow/disallow the DHCP port on WLAN interface
+#define COMMAND_IPTABLE_DHCP_INSERT  "IPTABLE_DHCP_INSERT"
+#define COMMAND_IPTABLE_DHCP_DELETE  "IPTABLE_DHCP_DELETE"
+#define COMMAND_DNSMASQ_RESTART       "DNSMASQ_RESTART"
 
 //--------------------------------------------------------------------------------------------------
 /**
  * WiFi platform adaptor shell script
  */
 //--------------------------------------------------------------------------------------------------
-#define WIFI_SCRIPT_PATH "/legato/systems/current/apps/wifiService/read-only/pa_wifi.sh "
+#define WIFI_SCRIPT_PATH "/legato/systems/current/apps/wifiService/read-only/pa_wifi "
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -63,10 +62,9 @@
  * Host access point global configuration.
  */
 //--------------------------------------------------------------------------------------------------
-#define WIFI_AP_CONFIG_HOSTAPD \
-    "interface=wlan0\n"\
+#define HOSTAPD_CONFIG_COMMON \
     "driver=nl80211\n"\
-    "hw_mode=g\n"\
+    "wmm_enabled=1\n"\
     "beacon_int=100\n"\
     "dtim_period=2\n"\
     "rts_threshold=2347\n"\
@@ -78,18 +76,17 @@
  * Host access point configuration with security disabled.
  */
 //--------------------------------------------------------------------------------------------------
-#define WIFI_AP_CONFIG_SECURITY_NONE \
+#define HOSTAPD_CONFIG_SECURITY_NONE \
     "auth_algs=1\n"\
     "eap_server=0\n"\
     "eapol_key_index_workaround=0\n"\
-    "wmm_enabled=1\n"\
     "macaddr_acl=0\n"
 //--------------------------------------------------------------------------------------------------
 /**
  * Host access point configuration with security enabled.
  */
 //--------------------------------------------------------------------------------------------------
-#define WIFI_AP_CONFIG_SECURITY_WPA2 \
+#define HOSTAPD_CONFIG_SECURITY_WPA2 \
     "wpa=2\n"\
     "wpa_key_mgmt=WPA-PSK\n"\
     "wpa_pairwise=CCMP\n"\
@@ -100,20 +97,56 @@
  * Maximum numbers of WiFi connections for the TI chip
  */
 //--------------------------------------------------------------------------------------------------
-#define TI_WIFI_MAX_USERS 10
+#define WIFI_MAX_USERS 10
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Hardware mode mask
+ */
+//--------------------------------------------------------------------------------------------------
+#define HARDWARE_MODE_MASK 0x000F
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Maximum numbers of bytes in temporary string written to hostapd.conf
+ */
+//--------------------------------------------------------------------------------------------------
+#define TEMP_STRING_MAX_BYTES 1024
 //--------------------------------------------------------------------------------------------------
 /**
  * The current security protocol
  */
 //--------------------------------------------------------------------------------------------------
-static le_wifiAp_SecurityProtocol_t SavedSecurityProtocol;
+static le_wifiAp_SecurityProtocol_t SavedSecurityProtocol =
+                                                    LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL;
 //--------------------------------------------------------------------------------------------------
 /**
  * The current SSID
  */
 //--------------------------------------------------------------------------------------------------
-static char                         SavedSsid[LE_WIFIDEFS_MAX_SSID_BYTES] = "";
+static char          SavedSsid[LE_WIFIDEFS_MAX_SSID_BYTES] = "";
+//--------------------------------------------------------------------------------------------------
+/**
+ * The current country code
+ */
+//--------------------------------------------------------------------------------------------------
+static char          SavedCountryCode[LE_WIFIDEFS_MAX_COUNTRYCODE_BYTES] = { 'U', 'S', '\0'};
+//--------------------------------------------------------------------------------------------------
+/**
+ * The current IEEE mask
+ * IEEE 802.11g is set by default
+ */
+//--------------------------------------------------------------------------------------------------
+static le_wifiAp_IeeeStdBitMask_t   SavedIeeeStdMask = 0x0004;
+//--------------------------------------------------------------------------------------------------
+/**
+ * The current MAX and MIN channel
+ * Different MAX/MIN channel for different hardware mode
+ * IEEE 802.11g is set by default
+ */
+//--------------------------------------------------------------------------------------------------
+static uint16_t MIN_CHANNEL_VALUE = LE_WIFIDEFS_MIN_CHANNEL_VALUE;
+static uint16_t MAX_CHANNEL_VALUE = LE_WIFIDEFS_MAX_CHANNEL_VALUE;
 //--------------------------------------------------------------------------------------------------
 /**
  * Defines whether the SSID is hidden or not
@@ -122,16 +155,18 @@ static char                         SavedSsid[LE_WIFIDEFS_MAX_SSID_BYTES] = "";
 static bool                         SavedDiscoverable                     = true;
 //--------------------------------------------------------------------------------------------------
 /**
- * The WiFi channel associated with the SSID
+ * The WiFi channel associated with the SSID.
+ * In the 2.4 GHz band, 1, 6, and 11 are the only non-overlapping channels.
+ * Default channel is set to 6
  */
 //--------------------------------------------------------------------------------------------------
-static uint32_t                     SavedChannelNumber                    = 1;
+static uint16_t                     SavedChannelNumber                    = 6;
 //--------------------------------------------------------------------------------------------------
 /**
  * The maximum numbers of clients the AP is able to manage
  */
 //--------------------------------------------------------------------------------------------------
-static uint32_t                     SavedMaxNumClients                    = TI_WIFI_MAX_USERS;
+static uint32_t                     SavedMaxNumClients                    = WIFI_MAX_USERS;
 
 // WPA-Personal
 //--------------------------------------------------------------------------------------------------
@@ -171,7 +206,7 @@ static FILE            *IwThreadPipePtr = NULL;
  * WifiAp state event ID used to report WifiAp state events to the registered event handlers.
  */
 //--------------------------------------------------------------------------------------------------
-static le_event_Id_t WifiApPaEvent;
+static le_event_Id_t    WifiApPaEvent;
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -186,8 +221,9 @@ static void ThreadDestructor
     int status;
 
     // Kill the script launched by popen() in PA thread
-    status = system("pid=`pgrep -f \""COMMAND_WIFI_SET_EVENT"\"`; [ -n \"$pid\" ] && kill -9 $pid");
-    if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    status = system(WIFI_SCRIPT_PATH COMMAND_WIFI_UNSET_EVENT);
+
+    if ((!WIFEXITED(status)) || (0 != WEXITSTATUS(status)))
     {
         LE_ERROR("Unable to kill the WIFI events script");
     }
@@ -237,20 +273,19 @@ static void *WifiApPaThreadMain
     void *contextPtr
 )
 {
-    char tmpString[] = (WIFI_SCRIPT_PATH COMMAND_WIFI_SET_EVENT);
     char path[1024];
 
-    LE_INFO("Started!");
+    LE_INFO("Wifi event report thread started!");
 
     // Open the command "iw events" for reading.
-    IwThreadPipePtr = popen(tmpString, "r");
+    IwThreadPipePtr = popen(WIFI_SCRIPT_PATH COMMAND_WIFI_SET_EVENT, "r");
 
     if (NULL == IwThreadPipePtr)
     {
         LE_ERROR("Failed to run command:\"%s\" errno:%d %s",
-            (tmpString),
-            errno,
-            strerror(errno));
+                COMMAND_WIFI_SET_EVENT,
+                errno,
+                strerror(errno));
         return NULL;
     }
 
@@ -312,6 +347,155 @@ static le_result_t WriteApCfgFile
     return LE_OK;
 }
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * This function writes configuration to hostapd.conf.
+ *
+ * @return LE_FAULT  The function failed.
+ * @return LE_OK     The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+static le_result_t GenerateHostapdConf
+(
+    void
+)
+{
+    char        tmpConfig[TEMP_STRING_MAX_BYTES];
+    le_result_t result = LE_FAULT;
+    FILE        *configFilePtr  = NULL;
+
+    configFilePtr = fopen(WIFI_HOSTAPD_FILE, "w");
+    if (NULL ==  configFilePtr)
+    {
+        LE_ERROR("Unable to create hostapd.conf file.");
+        return LE_FAULT;
+    }
+
+    memset(tmpConfig, '\0', sizeof(tmpConfig));
+    // prepare SSID, channel, country code etc in hostapd.conf
+    snprintf(tmpConfig, sizeof(tmpConfig), (HOSTAPD_CONFIG_COMMON
+            "ssid=%s\nchannel=%d\nmax_num_sta=%d\ncountry_code=%s\nignore_broadcast_ssid=%d\n"),
+            (char *)SavedSsid,
+            SavedChannelNumber,
+            SavedMaxNumClients,
+            (char *)SavedCountryCode,
+            !SavedDiscoverable);
+    // Write common config such as SSID, channel, country code, etc in hostapd.conf
+    tmpConfig[TEMP_STRING_MAX_BYTES - 1] = '\0';
+    if (LE_OK != WriteApCfgFile(tmpConfig, configFilePtr))
+    {
+        LE_ERROR("Unable to set SSID, channel, etc in hostapd.conf");
+        goto error;
+    }
+
+    memset(tmpConfig, '\0', sizeof(tmpConfig));
+    // Write security parameters in hostapd.conf
+    switch (SavedSecurityProtocol)
+    {
+        case LE_WIFIAP_SECURITY_NONE:
+            LE_DEBUG("LE_WIFIAP_SECURITY_NONE");
+            result = WriteApCfgFile(HOSTAPD_CONFIG_SECURITY_NONE, configFilePtr);
+            break;
+
+        case LE_WIFIAP_SECURITY_WPA2:
+            LE_DEBUG("LE_WIFIAP_SECURITY_WPA2");
+            if ('\0' != SavedPassphrase[0])
+            {
+                snprintf(tmpConfig, sizeof(tmpConfig), (HOSTAPD_CONFIG_SECURITY_WPA2
+                        "wpa_passphrase=%s\n"), SavedPassphrase);
+                tmpConfig[TEMP_STRING_MAX_BYTES - 1] = '\0';
+                result = WriteApCfgFile(tmpConfig, configFilePtr);
+            }
+            else if ('\0' != SavedPreSharedKey[0])
+            {
+                snprintf(tmpConfig, sizeof(tmpConfig), (HOSTAPD_CONFIG_SECURITY_WPA2
+                        "wpa_psk=%s\n"), SavedPreSharedKey);
+                tmpConfig[TEMP_STRING_MAX_BYTES - 1] = '\0';
+                result = WriteApCfgFile(tmpConfig, configFilePtr);
+            }
+            else
+            {
+                LE_ERROR("Security protocol is missing!");
+                result = LE_FAULT;
+            }
+            break;
+
+        default:
+            LE_ERROR("Unsupported security protocol!");
+            result = LE_FAULT;
+            break;
+    }
+
+    // Write security parameters in hostapd.conf
+    if (LE_OK != result)
+    {
+        LE_ERROR("Unable to set security parameters in hostapd.conf");
+        goto error;
+    }
+
+    // prepare IEEE std including hardware mode into hostapd.conf
+    memset(tmpConfig, '\0', sizeof(tmpConfig));
+    switch( SavedIeeeStdMask & HARDWARE_MODE_MASK )
+    {
+        case LE_WIFIAP_BITMASK_IEEE_STD_A:
+            le_utf8_Copy(tmpConfig, "hw_mode=a\n", sizeof(tmpConfig), NULL);
+            break;
+        case LE_WIFIAP_BITMASK_IEEE_STD_B:
+            le_utf8_Copy(tmpConfig, "hw_mode=b\n", sizeof(tmpConfig), NULL);
+            break;
+        case LE_WIFIAP_BITMASK_IEEE_STD_G:
+            le_utf8_Copy(tmpConfig, "hw_mode=g\n", sizeof(tmpConfig), NULL);
+            break;
+        case LE_WIFIAP_BITMASK_IEEE_STD_AD:
+            le_utf8_Copy(tmpConfig, "hw_mode=ad\n", sizeof(tmpConfig), NULL);
+            break;
+        default:
+            le_utf8_Copy(tmpConfig, "hw_mode=g\n", sizeof(tmpConfig), NULL);
+            break;
+    }
+
+    if ( SavedIeeeStdMask & LE_WIFIAP_BITMASK_IEEE_STD_D )
+    {
+        le_utf8_Append(tmpConfig, "ieee80211d=1\n", sizeof(tmpConfig), NULL);
+    }
+    if ( SavedIeeeStdMask & LE_WIFIAP_BITMASK_IEEE_STD_H )
+    {
+        le_utf8_Append(tmpConfig, "ieee80211h=1\n", sizeof(tmpConfig), NULL);
+    }
+    if ( SavedIeeeStdMask & LE_WIFIAP_BITMASK_IEEE_STD_N )
+    {
+        // hw_mode=b does not support ieee80211n, but driver can handle it
+        le_utf8_Append(tmpConfig, "ieee80211n=1\n", sizeof(tmpConfig), NULL);
+    }
+    if ( SavedIeeeStdMask & LE_WIFIAP_BITMASK_IEEE_STD_AC )
+    {
+        le_utf8_Append(tmpConfig, "ieee80211ac=1\n", sizeof(tmpConfig), NULL);
+    }
+    if ( SavedIeeeStdMask & LE_WIFIAP_BITMASK_IEEE_STD_AX )
+    {
+        le_utf8_Append(tmpConfig, "ieee80211ax=1\n", sizeof(tmpConfig), NULL);
+    }
+    if ( SavedIeeeStdMask & LE_WIFIAP_BITMASK_IEEE_STD_W )
+    {
+        le_utf8_Append(tmpConfig, "ieee80211w=1\n", sizeof(tmpConfig), NULL);
+    }
+    // Write IEEE std in hostapd.conf
+    tmpConfig[TEMP_STRING_MAX_BYTES - 1] = '\0';
+    if (LE_OK != WriteApCfgFile(tmpConfig, configFilePtr))
+    {
+        LE_ERROR("Unable to set IEEE std in hostapd.conf");
+        goto error;
+    }
+    fclose(configFilePtr);
+    return LE_OK;
+
+error:
+    fclose(configFilePtr);
+    // Remove generated hostapd.conf file
+    remove(WIFI_HOSTAPD_FILE);
+    return LE_FAULT;
+}
+
 #ifdef SIMU
 // SIMU variable for timers
 static le_timer_Ref_t SimuClientConnectTimer = NULL;
@@ -347,7 +531,6 @@ static void SimuClientConnectTimeCallBack
 
 //--------------------------------------------------------------------------------------------------
 /**
- * TODO: SIMULATION to remove/move
  * This function activates some timers to simulate client connect/disconnect events.
  */
 //--------------------------------------------------------------------------------------------------
@@ -405,7 +588,6 @@ le_result_t pa_wifiAp_Init
     // Create the event for signaling user handlers.
     WifiApPaEvent = le_event_CreateId("WifiApPaEvent", sizeof(le_wifiAp_Event_t));
 
-    // TODO: Temporary fix
     systemResult = system("chmod 755 " WIFI_SCRIPT_PATH);
 
     if (0 == WEXITSTATUS (systemResult))
@@ -446,6 +628,8 @@ le_result_t pa_wifiAp_Release
  *
  * @return LE_FAULT         The function failed.
  * @return LE_OK            The function succeeded.
+ * @return LE_NOT_FOUND     The WiFi card is absent.
+ * @return LE_NOT_POSSIBLE  The WiFi card may not work.
  *
  */
 //--------------------------------------------------------------------------------------------------
@@ -454,117 +638,80 @@ le_result_t pa_wifiAp_Start
     void
 )
 {
-    le_result_t  result         = LE_FAULT;
-    char         tmpString[256];
-    int          status;
-    FILE        *configFilePtr  = NULL;
+    int     systemResult;
 
-    // Check than an SSID is provided before starting
+    // Check that an SSID is provided before starting
     if ('\0' == SavedSsid[0])
     {
         LE_ERROR("Unable to start AP because no valid SSID provided");
         return LE_FAULT;
     }
 
-    LE_DEBUG("Starting AP, SSID: %s", SavedSsid);
-
-    // Create WiFi AP PA Thread
-    WifiApPaThread = le_thread_Create("WifiApPaThread", WifiApPaThreadMain, NULL);
-    le_thread_SetJoinable(WifiApPaThread);
-    le_thread_AddChildDestructor(WifiApPaThread, ThreadDestructor, NULL);
-    le_thread_Start(WifiApPaThread);
-
-    // Mount WiFi network interface. Returned values:
-    //  0: if the interface is correctly mounted
-    // -1: if the fork() has failed (see man system)
-    // 91: if module is not loaded or interface not seen
-    status = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_START);
-    if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    // Check channel number is properly set before starting
+    if ((SavedChannelNumber < MIN_CHANNEL_VALUE) ||
+            (SavedChannelNumber > MAX_CHANNEL_VALUE))
     {
-        LE_ERROR("WiFi AP Command Failed: (%d)" COMMAND_WIFI_HW_START, status);
-        goto error;
+        LE_ERROR("Unable to start AP because no valid channel number provided");
+        return LE_FAULT;
     }
 
-    // Create hostapd.conf file in /tmp
-    configFilePtr = fopen(WIFI_HOSTAPD_FILE, "w");
-    if (NULL ==  configFilePtr)
-    {
-        LE_ERROR("Unable to create hostapd.conf file.");
-        goto error;
-    }
+    LE_DEBUG("Starting AP, SSID: %s", SavedSsid);
 
-    // Write default configuration in hostapd.conf
-    if (LE_OK != WriteApCfgFile(WIFI_AP_CONFIG_HOSTAPD, configFilePtr))
+    // Create hostapd.conf file in /tmp
+    if ( LE_OK != GenerateHostapdConf())
     {
-        LE_ERROR("Unable to set default configuration in hostapd.conf");
-        goto error;
+        LE_ERROR("Failed to generate hostapd.conf");
+        return LE_FAULT;
     }
 
-    snprintf(tmpString, sizeof(tmpString), "ssid=%s\nchannel=%d\nmax_num_sta=%d\n",
-             (char *)SavedSsid,
-             SavedChannelNumber,
-             SavedMaxNumClients);
-
-    // Write SSID, channel and maximum number of clients in hostapd.conf
-    if (LE_OK != WriteApCfgFile(tmpString, configFilePtr))
+    systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_START);
+    /**
+     * Returned values:
+     *   0: if the interface is correctly moutned
+     *  50: if WiFi card is not inserted
+     * 100: if WiFi card may not work
+     * 127: if driver can not be installed
+     *  -1: if the fork() has failed (see man system)
+     */
+
+    if (0 == WEXITSTATUS(systemResult))
     {
-        LE_ERROR("Unable to set SSID, channel and maximum number of clients in hostapd.conf");
-        goto error;
+        LE_DEBUG("WiFi hardware started correctly");
+        // Create WiFi AP PA Thread
+        WifiApPaThread = le_thread_Create("WifiApPaThread", WifiApPaThreadMain, NULL);
+        le_thread_SetJoinable(WifiApPaThread);
+        le_thread_AddChildDestructor(WifiApPaThread, ThreadDestructor, NULL);
+        le_thread_Start(WifiApPaThread);
     }
-
-    // Write security parameters in hostapd.conf
-    switch (SavedSecurityProtocol)
+    // Return value of 50 means WiFi card is not inserted.
+    else if ( PA_NOT_FOUND == WEXITSTATUS(systemResult))
     {
-        case LE_WIFIAP_SECURITY_NONE:
-            LE_DEBUG("LE_WIFIAP_SECURITY_NONE");
-            result = WriteApCfgFile(WIFI_AP_CONFIG_SECURITY_NONE, configFilePtr);
-            break;
-
-        case LE_WIFIAP_SECURITY_WPA2:
-            LE_DEBUG("LE_WIFIAP_SECURITY_WPA2");
-            result = WriteApCfgFile(WIFI_AP_CONFIG_SECURITY_WPA2, configFilePtr);
-            if ('\0' != SavedPassphrase[0])
-            {
-                snprintf(tmpString, sizeof(tmpString), "wpa_passphrase=%s\n", SavedPassphrase);
-                result = WriteApCfgFile(tmpString, configFilePtr);
-            }
-            else if ('\0' != SavedPreSharedKey[0])
-            {
-                snprintf(tmpString, sizeof(tmpString), "wpa_psk=%s\n", SavedPreSharedKey);
-                result = WriteApCfgFile(tmpString, configFilePtr);
-            }
-            else
-            {
-                LE_ERROR("Security protocol is missing!");
-                result = LE_FAULT;
-            }
-            break;
-
-        default:
-            result = LE_FAULT;
-            break;
+        LE_ERROR("WiFi card is not inserted");
+        return LE_NOT_FOUND;
     }
-
-    if (LE_OK != result)
+    // Return value of 100 means WiFi card may not work.
+    else if ( PA_NOT_POSSIBLE == WEXITSTATUS(systemResult))
     {
-        LE_ERROR("Unable to set security parameters in hostapd.conf");
-        goto error;
+        LE_ERROR("Unable to reset WiFi card");
+        return LE_NOT_POSSIBLE;
     }
-
-    // Set whether SSID should be announced or not
-    snprintf(tmpString, sizeof(tmpString), "ignore_broadcast_ssid=%d\n", !SavedDiscoverable);
-    if (LE_OK != WriteApCfgFile(tmpString, configFilePtr))
+    // WiFi card failed to start.
+    else
     {
-        LE_ERROR("Unable to set broadcast paramater in hostapd.conf");
+        LE_WARN("Failed to start WiFi AP command \"%s\" systemResult (%d)",
+                COMMAND_WIFI_HW_START, systemResult);
+        return LE_FAULT;
     }
 
-    fclose(configFilePtr);
-
     // Start Access Point cmd: /bin/hostapd /etc/hostapd.conf
-    status = system(WIFI_SCRIPT_PATH COMMAND_WIFIAP_HOSTAPD_START);
-     if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFIAP_HOSTAPD_START);
+    if ((!WIFEXITED(systemResult)) || (0 != WEXITSTATUS(systemResult)))
     {
-        LE_ERROR("WiFi Client Command Failed: (%d)" COMMAND_WIFIAP_HOSTAPD_START, status);
+        LE_ERROR("WiFi Client Command \"%s\" Failed: (%d)",
+                COMMAND_WIFIAP_HOSTAPD_START,
+                systemResult);
+        // Remove generated hostapd.conf file
+        remove(WIFI_HOSTAPD_FILE);
         goto error;
     }
 
@@ -572,8 +719,6 @@ le_result_t pa_wifiAp_Start
     return LE_OK;
 
 error:
-    if (configFilePtr) fclose(configFilePtr);
-    remove(WIFI_HOSTAPD_FILE);
     le_thread_Cancel(WifiApPaThread);
     le_thread_Join(WifiApPaThread, NULL);
     return LE_FAULT;
@@ -595,24 +740,26 @@ le_result_t pa_wifiAp_Stop
 {
     int status;
 
-    // Try to delete the rule allowing the DHCP ports on wlan0. Ignore if it fails
-    status = system("iptables -D " COMMAND_IPTABLE_DHCP_WLAN0);
-     if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    // Try to delete the rule allowing the DHCP ports on WLAN. Ignore if it fails
+    status = system(WIFI_SCRIPT_PATH COMMAND_IPTABLE_DHCP_DELETE);
+    if ((!WIFEXITED(status)) || (0 != WEXITSTATUS(status)))
     {
         LE_WARN("Deleting rule for DHCP port fails");
     }
 
     status = system(WIFI_SCRIPT_PATH COMMAND_WIFIAP_HOSTAPD_STOP);
-     if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    if ((!WIFEXITED(status)) || (0 != WEXITSTATUS(status)))
     {
-        LE_ERROR("WiFi Client Command Failed: (%d)" COMMAND_WIFIAP_HOSTAPD_STOP, status);
+        LE_ERROR("WiFi AP Command \"%s\" Failed: (%d)",
+                COMMAND_WIFIAP_HOSTAPD_STOP,
+                status);
         return LE_FAULT;
     }
 
     status = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_STOP);
-     if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    if ((!WIFEXITED(status)) || (0 != WEXITSTATUS(status)))
     {
-        LE_ERROR("WiFi Access Point Command Failed: (%d)" COMMAND_WIFI_HW_STOP, status);
+        LE_ERROR("WiFi AP Command \"%s\" Failed: (%d)", COMMAND_WIFI_HW_STOP, status);
         return LE_FAULT;
     }
 
@@ -654,9 +801,9 @@ le_result_t  pa_wifiAp_AddEventHandler
     le_event_HandlerRef_t handlerRef;
 
     handlerRef = le_event_AddLayeredHandler("WifiApPaHandler",
-        WifiApPaEvent,
-        FirstLayerWifiApEventHandler,
-        (le_event_HandlerFunc_t)handlerPtr);
+                                            WifiApPaEvent,
+                                            FirstLayerWifiApEventHandler,
+                                            (le_event_HandlerFunc_t)handlerPtr);
     if (NULL == handlerRef)
     {
         LE_ERROR("ERROR: le_event_AddLayeredHandler returned NULL");
@@ -691,9 +838,9 @@ le_result_t pa_wifiAp_SetSsid
     le_result_t result = LE_BAD_PARAMETER;
 
     LE_INFO("SSID length %d | SSID: \"%.*s\"",
-        (int)ssidNumElements,
-        (int)ssidNumElements,
-        (char *)ssidPtr);
+            (int)ssidNumElements,
+            (int)ssidNumElements,
+            (char *)ssidPtr);
 
     if ((0 < ssidNumElements) && (ssidNumElements <= LE_WIFIDEFS_MAX_SSID_LENGTH))
     {
@@ -776,9 +923,7 @@ le_result_t pa_wifiAp_SetPassPhrase
             (length <= LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH))
         {
             // Store Passphrase to be used later during startup procedure
-            strncpy(&SavedPassphrase[0], &passphrasePtr[0], length);
-            // Make sure there is a null termination
-            SavedPassphrase[length] = '\0';
+            le_utf8_Copy(SavedPassphrase, passphrasePtr, sizeof(SavedPassphrase), NULL);
             result = LE_OK;
         }
         else
@@ -821,9 +966,7 @@ le_result_t pa_wifiAp_SetPreSharedKey
         if (length <= LE_WIFIDEFS_MAX_PSK_LENGTH)
         {
             // Store PSK to be used later during startup procedure
-            strncpy( &SavedPreSharedKey[0], &preSharedKeyPtr[0], length );
-            // Make sure there is a null termination
-            SavedPreSharedKey[length] = '\0';
+            le_utf8_Copy(SavedPreSharedKey, preSharedKeyPtr, sizeof(SavedPreSharedKey), NULL);
             result = LE_OK;
         }
     }
@@ -855,28 +998,50 @@ le_result_t pa_wifiAp_SetDiscoverable
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Set the WiFi channel to use.
- * Default value is 1.
- * Some legal restrictions for values 12 - 14 might apply for your region.
- *
- * @return LE_OUT_OF_RANGE Requested channel number is out of range.
- * @return LE_OK           Function succeeded.
+ * Set which WiFi channel to use.
+ * Default number is 7.
+ * Some legal restrictions might apply for your region.
+ * The channel number must be between 1 and 14 for IEEE 802.11b/g.
+ * The channel number must be between 7 and 196 for IEEE 802.11a.
+ * The channel number must be between 1 and 6 for IEEE 802.11ad.
+ * @return
+ *      - LE_OUT_OF_RANGE if requested channel number is out of range.
+ *      - LE_OK if the function succeeded.
  *
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t pa_wifiAp_SetChannel
 (
-    int8_t channelNumber
+    uint16_t channelNumber
         ///< [IN]
-        ///< the channel number must be between 1 and 14.
+        ///< the channel number.
 )
 {
-    // Store PreSharedKey to be used later during startup procedure
     le_result_t result = LE_OUT_OF_RANGE;
+    int8_t hwMode = SavedIeeeStdMask & 0x0F;
 
     LE_INFO("Set channel");
-    if ((channelNumber >= LE_WIFIDEFS_MIN_CHANNEL_VALUE) &&
-        (channelNumber <= LE_WIFIDEFS_MAX_CHANNEL_VALUE))
+    switch (hwMode)
+    {
+        case LE_WIFIAP_BITMASK_IEEE_STD_A:
+            MIN_CHANNEL_VALUE = LE_WIFIDEFS_MIN_CHANNEL_STD_A;
+            MAX_CHANNEL_VALUE = LE_WIFIDEFS_MAX_CHANNEL_STD_A;
+            break;
+        case LE_WIFIAP_BITMASK_IEEE_STD_B:
+        case LE_WIFIAP_BITMASK_IEEE_STD_G:
+            MIN_CHANNEL_VALUE = LE_WIFIDEFS_MIN_CHANNEL_VALUE;
+            MAX_CHANNEL_VALUE = LE_WIFIDEFS_MAX_CHANNEL_VALUE;
+            break;
+        case LE_WIFIAP_BITMASK_IEEE_STD_AD:
+            MIN_CHANNEL_VALUE = LE_WIFIDEFS_MIN_CHANNEL_STD_AD;
+            MAX_CHANNEL_VALUE = LE_WIFIDEFS_MAX_CHANNEL_STD_AD;
+            break;
+        default:
+            LE_WARN("Invalid hardware mode");
+    }
+
+    if ((channelNumber >= MIN_CHANNEL_VALUE) &&
+        (channelNumber <= MAX_CHANNEL_VALUE))
     {
        SavedChannelNumber = channelNumber;
        result = LE_OK;
@@ -884,6 +1049,129 @@ le_result_t pa_wifiAp_SetChannel
     return result;
 }
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set which IEEE standard to use.
+ * Default hardware mode is IEEE 802.11g.
+ *
+ * @return
+ *      - LE_BAD_PARAMETER if invalid IEEE standard is set.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiAp_SetIeeeStandard
+(
+    le_wifiAp_IeeeStdBitMask_t stdMask
+        ///< [IN]
+        ///< Bit mask for the IEEE standard.
+)
+{
+    int8_t hwMode = stdMask & 0x0F;
+    int8_t numCheck = (hwMode & 0x1) + ((hwMode >> 1) & 0x1) +
+                       ((hwMode >> 2) & 0x1) + ((hwMode >> 3) & 0x1);
+
+    LE_INFO("Set IeeeStdBitMask : 0x%X", stdMask);
+    //Hardware mode should be set.
+    if ( 0 == numCheck )
+    {
+        LE_WARN("No hardware mode is set.");
+        return LE_BAD_PARAMETER;
+    }
+    //Hardware mode should be exclusive.
+    if ( numCheck > 1 )
+    {
+        LE_WARN("Only one hardware mode can be set.");
+        return LE_BAD_PARAMETER;
+    }
+
+    if ( stdMask & LE_WIFIAP_BITMASK_IEEE_STD_AC )
+    {
+        // ieee80211ac=1 only works with hw_mode=a
+        if ( 0 == (stdMask & LE_WIFIAP_BITMASK_IEEE_STD_A) )
+        {
+            LE_WARN("ieee80211ac=1 only works with hw_mode=a.");
+            return LE_BAD_PARAMETER;
+        }
+    }
+
+    if ( stdMask & LE_WIFIAP_BITMASK_IEEE_STD_H )
+    {
+        // ieee80211h=1 can be used only with ieee80211d=1
+        if ( 0 == (stdMask & LE_WIFIAP_BITMASK_IEEE_STD_D) )
+        {
+            LE_WARN("ieee80211h=1 only works with ieee80211d=1.");
+            return LE_BAD_PARAMETER;
+        }
+    }
+
+    SavedIeeeStdMask = stdMask;
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get which IEEE standard was set.
+ * Default hardware mode is IEEE 802.11g.
+ *
+ * @return
+ *      - LE_FAULT if the function failed.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiAp_GetIeeeStandard
+(
+    le_wifiAp_IeeeStdBitMask_t *stdMaskPtr
+        ///< [OUT]
+        ///< Bit mask for the IEEE standard.
+)
+{
+    if ( NULL == stdMaskPtr )
+    {
+        LE_WARN("stdMaskPtr == NULL");
+        return LE_FAULT;
+    }
+
+    *stdMaskPtr = SavedIeeeStdMask;
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set what country code to use for regulatory domain.
+ * ISO/IEC 3166-1 Alpha-2 code is used.
+ * Default country code is US.
+ * @return
+ *      - LE_FAULT if the function failed.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiAp_SetCountryCode
+(
+    const char *countryCodePtr
+        /// [IN]
+        ///< the country code.
+)
+{
+    le_result_t result = LE_FAULT;
+
+    LE_INFO("Set countryCode");
+    if (NULL != countryCodePtr)
+    {
+        uint32_t length = strlen(countryCodePtr);
+
+        if (length == LE_WIFIDEFS_ISO_COUNTRYCODE_LENGTH)
+        {
+            strncpy(&SavedCountryCode[0], &countryCodePtr[0], length );
+            SavedCountryCode[length] = '\0';
+            result = LE_OK;
+        }
+    }
+    return result;
+}
+
 //--------------------------------------------------------------------------------------------------
 /**
  * Set the maximum number of clients allowed to be connected to WiFi access point at the same time.
@@ -905,7 +1193,7 @@ le_result_t pa_wifiAp_SetMaxNumberClients
     // Store maxNumberClients to be used later during startup procedure
     le_result_t result = LE_OUT_OF_RANGE;
     LE_INFO("Set max clients");
-    if ((maxNumberClients >= 1) && (maxNumberClients <= TI_WIFI_MAX_USERS))
+    if ((maxNumberClients >= 1) && (maxNumberClients <= WIFI_MAX_USERS))
     {
        SavedMaxNumClients = maxNumberClients;
        result = LE_OK;
@@ -944,11 +1232,15 @@ le_result_t pa_wifiAp_SetIpRange
     const char         *parameterPtr = 0;
 
     // Check the parameters
-    if ((ipApPtr == NULL) || (ipStartPtr == NULL) || (ipStopPtr == NULL))
+    if ((NULL == ipApPtr) || (NULL == ipStartPtr) || (NULL == ipStopPtr))
+    {
         return LE_BAD_PARAMETER;
+    }
 
     if ((!strlen(ipApPtr)) || (!strlen(ipStartPtr)) || (!strlen(ipStopPtr)))
+    {
         return LE_BAD_PARAMETER;
+    }
 
     if (inet_pton(AF_INET, ipApPtr, &(saApPtr.sin_addr)) <= 0)
     {
@@ -999,7 +1291,10 @@ le_result_t pa_wifiAp_SetIpRange
         char cmd[256];
         int  systemResult;
 
-        snprintf((char *)&cmd, sizeof(cmd), "%s %s %s %s", "/sbin/ifconfig", "wlan0", ipApPtr, "up");
+        snprintf((char *)&cmd, sizeof(cmd), "%s %s %s",
+                WIFI_SCRIPT_PATH,
+                COMMAND_WIFIAP_WLAN_UP,
+                ipApPtr);
 
         systemResult = system(cmd);
         if (0 != WEXITSTATUS (systemResult))
@@ -1021,9 +1316,10 @@ le_result_t pa_wifiAp_SetIpRange
             filePtr = fopen (DNSMASQ_CFG_FILE, "w");
             if (filePtr != NULL)
             {
-                fprintf(filePtr, "dhcp-range=%s, %s,%s,%dh\n", "wlan0", ipStartPtr, ipStopPtr, 24);
-                fprintf(filePtr, "dhcp-option=%s, %d,%s\n","wlan0", 3, ipApPtr);
-                fprintf(filePtr, "dhcp-option=%s, %d,%s\n","wlan0", 6, ipApPtr);
+                //Interface is generated when COMMAND_DNSMASQ_RESTART called
+                fprintf(filePtr, "dhcp-range=%s,%s,%dh\n", ipStartPtr, ipStopPtr, 24);
+                fprintf(filePtr, "dhcp-option=%d,%s\n", 3, ipApPtr);
+                fprintf(filePtr, "dhcp-option=%d,%s\n", 6, ipApPtr);
                 fclose(filePtr);
             }
             else
@@ -1034,17 +1330,15 @@ le_result_t pa_wifiAp_SetIpRange
 
             LE_INFO("@AP=%s, @APstart=%s, @APstop=%s", ipApPtr, ipStartPtr, ipStopPtr);
 
-            // Insert the rule allowing the DHCP ports on wlan0
-            systemResult = system("iptables -I " COMMAND_IPTABLE_DHCP_WLAN0);
+            // Insert the rule allowing the DHCP ports on WLAN
+            systemResult = system(WIFI_SCRIPT_PATH COMMAND_IPTABLE_DHCP_INSERT);
             if (0 != WEXITSTATUS (systemResult))
             {
                 LE_ERROR("Unable to allow DHCP ports.");
                 return LE_FAULT;
             }
 
-            systemResult = system("/etc/init.d/dnsmasq stop; "
-                                  "pkill -9 dnsmasq; "
-                                  "/etc/init.d/dnsmasq start");
+            systemResult = system(WIFI_SCRIPT_PATH COMMAND_DNSMASQ_RESTART);
             if (0 != WEXITSTATUS (systemResult))
             {
                 LE_ERROR("Unable to restart the DHCP server.");
diff --git a/service/platformAdaptor/ti/pa_wifi_client_ti.c b/service/platformAdaptor/common/pa_wifi_client.c
similarity index 57%
rename from service/platformAdaptor/ti/pa_wifi_client_ti.c
rename to service/platformAdaptor/common/pa_wifi_client.c
index 30ef03d..0bde914 100644
--- a/service/platformAdaptor/ti/pa_wifi_client_ti.c
+++ b/service/platformAdaptor/common/pa_wifi_client.c
@@ -14,73 +14,50 @@
 #include "interfaces.h"
 
 #include "pa_wifi.h"
-#include "stdio.h"
 
 //--------------------------------------------------------------------------------------------------
 /**
  * WiFi platform adaptor shell script
  */
 //--------------------------------------------------------------------------------------------------
-#define WIFI_SCRIPT_PATH "/legato/systems/current/apps/wifiService/read-only/pa_wifi.sh "
+//Trailing space is needed to pass argument
+#define WIFI_SCRIPT_PATH "/legato/systems/current/apps/wifiService/read-only/pa_wifi "
+#define WPA_SUPPLICANT_FILE "/tmp/wpa_supplicant.conf"
 
 // Set of commands to drive the WiFi features.
-#define COMMAND_WIFI_HW_START "wlan0 WIFI_START"
-#define COMMAND_WIFI_HW_STOP "wlan0 WIFI_STOP" /* not sure that this works */
-#define COMMAND_WIFI_WLAN_UP "wlan0 WIFI_WLAN_UP"
-#define COMMAND_WIFI_SET_EVENT "wlan0 WIFI_SET_EVENT"
-#define COMMAND_WIFICLIENT_START_SCAN "wlan0 WIFICLIENT_START_SCAN"
-#define COMMAND_WIFICLIENT_DISCONNECT "wlan0 WIFICLIENT_DISCONNECT"
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_NONE \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_NONE \"%.*s\" \"%d\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WEP \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WEP \"%.*s\" \"%d\" \"%s\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_PASS_PERSONAL \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL \"%.*s\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_PASS_PERSONAL \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL \"%.*s\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL \"%.*s\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL \"%.*s\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE \"%.*s\" \"%d\" \"%s\" \"%s\""
-#define COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE \
-    "wlan0 WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE \"%.*s\" \"%d\" \"%s\" \"%s\""
-#define COMMAND_WIFICLIENT_CONNECT_WPA_PASSPHRASE \
-    "wlan0 WIFICLIENT_CONNECT_WPA_PASSPHRASE \"%.*s\" %s"
+#define COMMAND_WIFI_HW_START           "WIFI_START"
+#define COMMAND_WIFI_HW_STOP            "WIFI_STOP"
+#define COMMAND_WIFI_CHECK_HWSTATUS     "WIFI_CHECK_HWSTATUS"
+#define COMMAND_WIFI_SET_EVENT          "WIFI_SET_EVENT"
+#define COMMAND_WIFI_UNSET_EVENT        "WIFI_UNSET_EVENT"
+#define COMMAND_WIFICLIENT_START_SCAN   "WIFICLIENT_START_SCAN"
+#define COMMAND_WIFICLIENT_DISCONNECT   "WIFICLIENT_DISCONNECT"
+//Trailing space is needed to pass another argument by WIFI_SCRIPT_PATH
+#define COMMAND_WIFICLIENT_CONNECT      "WIFICLIENT_CONNECT "
 
 //--------------------------------------------------------------------------------------------------
 /**
- * The current security protocol.
+ * The common wpa configuration.
  */
 //--------------------------------------------------------------------------------------------------
-#define WPA_SUPPLICANT_FILE "/tmp/wpa_supplicant.conf"
-#define WPA_SUPPLICANT_DATA \
-    "ctrl_interface=/var/run/wpa_supplicant\n \
-    ctrl_interface_group=0\n \
-    update_config=1\n \
-    network={\n \
-    ssid=\"%.*s\"\n \
-    scan_ssid=%d\n \
-    psk=%s\n \
-    }\n"
-
-#define WPA_SUPPLICANT_DATA_NO_SECURITY \
-    "ctrl_interface=/var/run/wpa_supplicant\n \
-    ctrl_interface_group=0\n \
-    update_config=1\n \
-    network={\n \
-    ssid=\"%.*s\"\n \
-    scan_ssid=%d\n \
-    key_mgmt=NONE\n \
-    }\n"
+#define WPA_SUPPLICANT_CONFIG_COMMON \
+"ctrl_interface=/var/run/wpa_supplicant\n \
+ctrl_interface_group=0\n \
+update_config=1\n \
+network={\n \
+ssid=\"%.*s\"\n \
+scan_ssid=%d\n"
+
+//--------------------------------------------------------------------------------------------------
+#define PATH_MAX_BYTES      1024
 
 //--------------------------------------------------------------------------------------------------
 /**
  * The current security protocol.
  */
 //--------------------------------------------------------------------------------------------------
-static le_wifiClient_SecurityProtocol_t SavedSecurityProtocol;
+static le_wifiClient_SecurityProtocol_t SavedSecurityProtocol =
+                                                        LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL;
 
 // WEP
 //--------------------------------------------------------------------------------------------------
@@ -88,7 +65,7 @@ static le_wifiClient_SecurityProtocol_t SavedSecurityProtocol;
  * WEP key used for authentication. Used only with WEP protocol.
  */
 //--------------------------------------------------------------------------------------------------
-static char SavedWepKey[LE_WIFIDEFS_MAX_WEPKEY_BYTES];
+static char SavedWepKey[LE_WIFIDEFS_MAX_WEPKEY_BYTES] = {0};
 
 // WPA-Personal
 //--------------------------------------------------------------------------------------------------
@@ -96,13 +73,13 @@ static char SavedWepKey[LE_WIFIDEFS_MAX_WEPKEY_BYTES];
  * Passphrase used for authentication. Used only with WPA/WPA2 protocol.
  */
 //--------------------------------------------------------------------------------------------------
-static char SavedPassphrase[LE_WIFIDEFS_MAX_PASSPHRASE_BYTES];
+static char SavedPassphrase[LE_WIFIDEFS_MAX_PASSPHRASE_BYTES] = {0};
 //--------------------------------------------------------------------------------------------------
 /**
  * Pre-Shared-Key used for authentication. Used only with WPA/WPA2 protocol.
  */
 //--------------------------------------------------------------------------------------------------
-static char SavedPreSharedKey[LE_WIFIDEFS_MAX_PSK_BYTES];
+static char SavedPreSharedKey[LE_WIFIDEFS_MAX_PSK_BYTES] = {0};
 
 // WPA-Enterprise
 //--------------------------------------------------------------------------------------------------
@@ -110,13 +87,13 @@ static char SavedPreSharedKey[LE_WIFIDEFS_MAX_PSK_BYTES];
  * Username used for authentication. Used only with WPA/WPA2 protocol with RADIUS server.
  */
 //--------------------------------------------------------------------------------------------------
-static char SavedUsername[LE_WIFIDEFS_MAX_USERNAME_BYTES];
+static char SavedUsername[LE_WIFIDEFS_MAX_USERNAME_BYTES] = {0};
 //--------------------------------------------------------------------------------------------------
 /**
  * Password used for authentication. Used only with WPA/WPA2 protocol with RADIUS server.
  */
 //--------------------------------------------------------------------------------------------------
-static char SavedPassword[LE_WIFIDEFS_MAX_PASSWORD_BYTES];
+static char SavedPassword[LE_WIFIDEFS_MAX_PASSWORD_BYTES] = {0};
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -131,12 +108,6 @@ static bool HiddenAccessPoint = false;
 //--------------------------------------------------------------------------------------------------
 static FILE *IwScanPipePtr    = NULL;
 //--------------------------------------------------------------------------------------------------
-/**
- * The handle of the input pipe used to be notified of the WiFi (dis)connections.
- */
-//--------------------------------------------------------------------------------------------------
-static FILE *IwConnectPipePtr = NULL;
-//--------------------------------------------------------------------------------------------------
 /**
  * The handle of the input pipe used to be notified of the WiFi events.
  */
@@ -149,7 +120,6 @@ static FILE *IwThreadPipePtr  = NULL;
 //--------------------------------------------------------------------------------------------------
 static bool  IsScanRunning    = false;
 
-
 //--------------------------------------------------------------------------------------------------
 /**
  * The main thread running the WiFi platform adaptor.
@@ -165,10 +135,39 @@ static le_thread_Ref_t WifiClientPaThread = NULL;
 
 //--------------------------------------------------------------------------------------------------
 /**
- * WifiClient state event ID used to report WifiClient state events to the registered event handlers.
+ * WifiClient state event ID.
+ * Used to report WifiClient state events to the registered event handlers.
  */
 //--------------------------------------------------------------------------------------------------
 static le_event_Id_t WifiClientPaEvent;
+//--------------------------------------------------------------------------------------------------
+/**
+ * WifiClient state event ID.
+ * Used to report WifiClient state events to the registered event handlers.
+ */
+//--------------------------------------------------------------------------------------------------
+static le_event_Id_t WifiClientPaEventId;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Pool for WifiClient state events reporting.
+ */
+//--------------------------------------------------------------------------------------------------
+static le_mem_PoolRef_t WifiPaEventPool;
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Maximum numbers of bytes in temparatory string
+ */
+//--------------------------------------------------------------------------------------------------
+#define TEMP_STRING_MAX_BYTES 192
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Maximum numbers of bytes in temparatory config string written to wpa_supplicant.conf
+ */
+//--------------------------------------------------------------------------------------------------
+#define TEMP_CONFIG_MAX_BYTES 512
 
 //--------------------------------------------------------------------------------------------------
 /**
@@ -180,13 +179,14 @@ static void ThreadDestructor
     void *contextPtr
 )
 {
-    int status;
+    int systemResult;
 
     // Kill the script launched by popen() in Client thread
-    status = system("pid=`pgrep -f \""COMMAND_WIFI_SET_EVENT"\"`; [ -n \"$pid\" ] && kill -9 $pid");
-    if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFI_UNSET_EVENT);
+
+    if ((!WIFEXITED(systemResult)) || (0 != WEXITSTATUS(systemResult)))
     {
-        LE_ERROR("Unable to kill the WIFI events script");
+        LE_WARN("Unable to kill the WIFI events script");
     }
 
     if (IwThreadPipePtr)
@@ -200,6 +200,8 @@ static void ThreadDestructor
 //--------------------------------------------------------------------------------------------------
 /**
  * The first-layer WiFi Client Event Handler.
+ * @deprecated pa_wifiClient_AddEventHandler() should not be used anymore.
+ * It has been replaced by pa_wifiClient_AddEventIndHandler().
  *
  */
 //--------------------------------------------------------------------------------------------------
@@ -210,11 +212,11 @@ static void FirstLayerWifiClientEventHandler
 )
 {
     pa_wifiClient_NewEventHandlerFunc_t  clientHandlerFunc = secondLayerHandlerFuncPtr;
-    le_wifiClient_Event_t               *wifiEventPtr      = (le_wifiClient_Event_t *)reportPtr;
+    le_wifiClient_Event_t    *wifiEventPtr = (le_wifiClient_Event_t *)reportPtr;
 
     if (NULL != wifiEventPtr)
     {
-        LE_INFO("Event: %d", *wifiEventPtr);
+        LE_DEBUG("Event: %d", *wifiEventPtr);
         clientHandlerFunc(*wifiEventPtr, le_event_GetContextPtr());
     }
     else
@@ -223,6 +225,41 @@ static void FirstLayerWifiClientEventHandler
     }
 }
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * The first-layer WiFi Client Event Indication Handler.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+static void FirstLayerWifiClientEventIndHandler
+(
+    void *reportPtr,
+    void *secondLayerHandlerFuncPtr
+)
+{
+    pa_wifiClient_EventIndHandlerFunc_t  clientHandlerFunc = secondLayerHandlerFuncPtr;
+    le_wifiClient_EventInd_t*  wifiEventIndPtr = reportPtr;
+
+    if (NULL != wifiEventIndPtr)
+    {
+        LE_DEBUG("WiFi event: %d, interface: %s, bssid: %s",
+                wifiEventIndPtr->event,
+                wifiEventIndPtr->ifName,
+                wifiEventIndPtr->apBssid);
+
+        if (LE_WIFICLIENT_EVENT_DISCONNECTED == wifiEventIndPtr->event)
+        {
+            LE_DEBUG("disconnectCause: %d", wifiEventIndPtr->disconnectionCause);
+        }
+
+        clientHandlerFunc(wifiEventIndPtr, le_event_GetContextPtr());
+    }
+    else
+    {
+        LE_ERROR("wifiEventIndPtr is NULL");
+    }
+}
+
 //--------------------------------------------------------------------------------------------------
 /**
  * WiFi Client PA Thread
@@ -234,42 +271,160 @@ static void *WifiClientPaThreadMain
     void *contextPtr
 )
 {
-    char tmpString[] = (WIFI_SCRIPT_PATH COMMAND_WIFI_SET_EVENT);
-    char path[1024];
+    le_wifiClient_DisconnectionCause_t cause;
+    le_wifiClient_Event_t              event;
+    char path[PATH_MAX_BYTES];
+    char apBssid[LE_WIFIDEFS_MAX_BSSID_BYTES];
+    char *ret;
+    char *pathReentrant;
+    int  systemResult;
 
-    LE_INFO("Started!");
+    LE_INFO("Wifi event report thread started!");
 
-    // Open the command "iw events" for reading.
-    IwThreadPipePtr = popen(tmpString, "r");
+    IwThreadPipePtr = popen(WIFI_SCRIPT_PATH COMMAND_WIFI_SET_EVENT, "r");
 
     if (NULL == IwThreadPipePtr)
     {
         LE_ERROR("Failed to run command:\"%s\" errno:%d %s",
-            (tmpString),
-            errno,
-            strerror(errno));
+                COMMAND_WIFI_SET_EVENT,
+                errno,
+                strerror(errno));
         return NULL;
     }
 
+    memset(apBssid, 0, LE_WIFIDEFS_MAX_BSSID_BYTES);
+    cause = LE_WIFICLIENT_UNKNOWN_CAUSE;
     // Read the output one line at a time - output it.
     while (NULL != fgets(path, sizeof(path) - 1, IwThreadPipePtr))
     {
-        LE_INFO("PARSING:%s: len:%d", path, (int) strnlen(path, sizeof(path) - 1));
-        if (NULL != strstr(path, "connected to"))
+        LE_DEBUG("PARSING:%s: len:%d", path, (int) strnlen(path, sizeof(path) - 1));
+
+        if (NULL != strstr(path, "Beacon loss"))
+        {
+            cause = LE_WIFICLIENT_BEACON_LOSS;
+        }
+        if (NULL != (ret = strstr(path, "del station")))
+        {
+            memset(apBssid, 0, LE_WIFIDEFS_MAX_BSSID_BYTES);
+            memcpy(apBssid, &ret[sizeof("del station")],
+                   LE_WIFIDEFS_MAX_BSSID_LENGTH);
+            apBssid[LE_WIFIDEFS_MAX_BSSID_LENGTH] = '\0';
+        }
+        if (NULL != (ret = strstr(path, "connected to")))
         {
             LE_INFO("FOUND connected");
+
+            cause = LE_WIFICLIENT_UNKNOWN_CAUSE;
+            le_wifiClient_EventInd_t* WifiClientPaEventPtr = le_mem_ForceAlloc(WifiPaEventPool);
+            memset(WifiClientPaEventPtr, 0, sizeof(le_wifiClient_EventInd_t));
+            WifiClientPaEventPtr->event = LE_WIFICLIENT_EVENT_CONNECTED;
+            WifiClientPaEventPtr->disconnectionCause = cause;
+            // Retrieve AP BSSID
+            memcpy(WifiClientPaEventPtr->apBssid, &ret[sizeof("connected to")],
+                    LE_WIFIDEFS_MAX_BSSID_LENGTH);
+            WifiClientPaEventPtr->apBssid[LE_WIFIDEFS_MAX_BSSID_LENGTH] = '\0';
+            // Retrieve WLAN interface name
+            pathReentrant = path;
+            ret = strtok_r(pathReentrant, " ", &pathReentrant);
+            if (NULL == ret)
+            {
+                LE_WARN("Failed to retrieve WLAN interface");
+                WifiClientPaEventPtr->ifName[0] = '\0';
+            }
+            else
+            {
+                memcpy(WifiClientPaEventPtr->ifName, ret, strlen(ret));
+                WifiClientPaEventPtr->ifName[LE_WIFIDEFS_MAX_IFNAME_LENGTH] = '\0';
+            }
             // Report event: LE_WIFICLIENT_EVENT_CONNECTED
-            le_wifiClient_Event_t event = LE_WIFICLIENT_EVENT_CONNECTED;
-            LE_INFO("InternalWifiClientStateEvent event: %d ", event);
+            LE_DEBUG("WiFi event: %d, interface: %s, bssid: %s",
+                     WifiClientPaEventPtr->event,
+                     WifiClientPaEventPtr->ifName,
+                     WifiClientPaEventPtr->apBssid);
+
+            le_event_ReportWithRefCounting(WifiClientPaEventId, WifiClientPaEventPtr);
+
+            // Report event: LE_WIFICLIENT_EVENT_CONNECTED (will be deprecated)
+            event = LE_WIFICLIENT_EVENT_CONNECTED;
             le_event_Report(WifiClientPaEvent, (void *)&event, sizeof(le_wifiClient_Event_t));
+
         }
         else if (NULL != strstr(path, "disconnected"))
         {
             LE_INFO("FOUND disconnected");
+
+            if (LE_WIFICLIENT_BEACON_LOSS != cause)
+            {
+                if (NULL != strstr(path, "local request"))
+                {
+                    // Check WLAN interface, not available means hardware removed
+                    systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFI_CHECK_HWSTATUS);
+
+                    switch (WEXITSTATUS(systemResult))
+                    {
+                        case 0:
+                            // WLAN interface is up, local request
+                            cause = LE_WIFICLIENT_CLIENT_REQUEST;
+                            break;
+                        case PA_NOT_POSSIBLE:
+                            // Driver removed, WiFi stop called
+                            cause = LE_WIFICLIENT_HARDWARE_STOP;
+                            break;
+                        case PA_NOT_FOUND:
+                            // WLAN interface is gone, WiFi hardware is removed
+                            cause = LE_WIFICLIENT_HARDWARE_DETACHED;
+                            break;
+                        default:
+                            LE_WARN("WiFi Client Command \"%s\" Failed: (%d)",
+                                COMMAND_WIFI_CHECK_HWSTATUS, systemResult);
+                            cause = LE_WIFICLIENT_CLIENT_REQUEST;
+
+                    }
+                }
+                // AP terminated connection
+                else if (NULL != strstr(path, "by AP"))
+                {
+                    cause = LE_WIFICLIENT_BY_AP;
+                }
+            }
+
+            le_wifiClient_EventInd_t* WifiClientPaEventPtr = le_mem_ForceAlloc(WifiPaEventPool);
+            memset(WifiClientPaEventPtr, 0, sizeof(le_wifiClient_EventInd_t));
+            WifiClientPaEventPtr->event = LE_WIFICLIENT_EVENT_DISCONNECTED;
+            //Disconnection cause
+            WifiClientPaEventPtr->disconnectionCause = cause;
+            // Retrieve WLAN interface name
+            pathReentrant = path;
+            ret = strtok_r(pathReentrant, " ", &pathReentrant);
+            if (NULL == ret)
+            {
+                LE_WARN("Failed to retrieve WLAN interface");
+                WifiClientPaEventPtr->ifName[0] = '\0';
+            }
+            else
+            {
+                memcpy(WifiClientPaEventPtr->ifName, ret, strlen(ret));
+                WifiClientPaEventPtr->ifName[LE_WIFIDEFS_MAX_IFNAME_LENGTH] = '\0';
+            }
+            // Retrieve AP BSSID
+            memcpy(WifiClientPaEventPtr->apBssid, apBssid, LE_WIFIDEFS_MAX_BSSID_LENGTH);
+            WifiClientPaEventPtr->apBssid[LE_WIFIDEFS_MAX_BSSID_LENGTH] = '\0';
+
             // Report event: LE_WIFICLIENT_EVENT_DISCONNECTED
-            le_wifiClient_Event_t event = LE_WIFICLIENT_EVENT_DISCONNECTED;
-            LE_INFO("InternalWifiClientStateEvent event: %d ", event);
+            LE_DEBUG("WiFi event: %d, disconnectCause: %d, interface: %s, bssid: %s",
+                     WifiClientPaEventPtr->event,
+                     WifiClientPaEventPtr->disconnectionCause,
+                     WifiClientPaEventPtr->ifName,
+                     WifiClientPaEventPtr->apBssid);
+
+            // Report event: LE_WIFICLIENT_EVENT_DISCONNECTED (will be deprecated)
+            event = LE_WIFICLIENT_EVENT_DISCONNECTED;
             le_event_Report(WifiClientPaEvent, (void *)&event, sizeof(le_wifiClient_Event_t));
+
+            // Restore to default value
+            cause = LE_WIFICLIENT_UNKNOWN_CAUSE;
+            memset(apBssid, 0, LE_WIFIDEFS_MAX_BSSID_BYTES);
+            le_event_ReportWithRefCounting(WifiClientPaEventId, WifiClientPaEventPtr);
         }
     }
     // Run the event loop
@@ -294,8 +449,11 @@ le_result_t pa_wifiClient_Init
 )
 {
     LE_INFO("Init called");
-    // Create the event for signaling user handlers.
+    // pa_wifiClient_AddEventHandler() will be deprecated
     WifiClientPaEvent = le_event_CreateId("WifiClientPaEvent", sizeof(le_wifiClient_Event_t));
+    // Create the event for signaling user handlers.
+    WifiClientPaEventId = le_event_CreateIdWithRefCounting("WifiConnectEvent");
+    WifiPaEventPool = le_mem_CreatePool("WifiPaEventPool", sizeof(le_wifiClient_EventInd_t));
 
     return LE_OK;
 }
@@ -320,8 +478,10 @@ le_result_t pa_wifiClient_Release
 /**
  * Start WiFi Client PA
  *
- * @return LE_FAULT  The function failed.
- * @return LE_OK     The function succeeded.
+ * @return LE_FAULT         The function failed.
+ * @return LE_OK            The function succeeded.
+ * @return LE_NOT_FOUND     The WiFi card is absent.
+ * @return LE_NOT_POSSIBLE  The WiFi card may not work.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t pa_wifiClient_Start
@@ -329,32 +489,51 @@ le_result_t pa_wifiClient_Start
     void
 )
 {
-    int status;
-
-    /* Create WiFi Client PA Thread */
-    WifiClientPaThread = le_thread_Create("WifiClientPaThread", WifiClientPaThreadMain, NULL);
-    le_thread_SetJoinable(WifiClientPaThread);
-    le_thread_AddChildDestructor(WifiClientPaThread, ThreadDestructor, NULL);
-    le_thread_Start(WifiClientPaThread);
+    int systemResult;
+    le_result_t result = LE_OK;
 
-    status = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_START);
+    systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_START);
     /**
      * Returned values:
-     *  0: if the interface is correctly moutned
-     * -1: if the fork() has failed (see man system)
-     * 91: if module is not loaded or interface not seen
+     *   0: if the interface is correctly moutned
+     *  50: if WiFi card is not inserted
+     * 100: if WiFi card may not work
+     * 127: if driver can not be installed
+     *  -1: if the fork() has failed (see man system)
      */
-    if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    // Return value of 0 means WLAN interface is up.
+    if (0 == WEXITSTATUS(systemResult))
     {
-        LE_ERROR("WiFi Client Command Failed: (%d)" COMMAND_WIFI_HW_START, status);
-        le_thread_Cancel(WifiClientPaThread);
-        le_thread_Join(WifiClientPaThread, NULL);
-        return LE_FAULT;
+        LE_DEBUG("WiFi client started correctly");
+
+        /* Create WiFi Client PA Thread */
+        WifiClientPaThread = le_thread_Create("WifiClientPaThread", WifiClientPaThreadMain, NULL);
+        le_thread_SetJoinable(WifiClientPaThread);
+        le_thread_AddChildDestructor(WifiClientPaThread, ThreadDestructor, NULL);
+        le_thread_Start(WifiClientPaThread);
+        return LE_OK;
+    }
+    // Return value of 50 means WiFi card is not inserted.
+    else if ( PA_NOT_FOUND == WEXITSTATUS(systemResult))
+    {
+        LE_ERROR("WiFi card is not inserted");
+        result = LE_NOT_FOUND;
+    }
+    // Return value of 100 means WiFi card may not work.
+    else if ( PA_NOT_POSSIBLE == WEXITSTATUS(systemResult))
+    {
+        LE_ERROR("Unable to reset WiFi card");
+        result = LE_NOT_POSSIBLE;
+    }
+    // WiFi card failed to start.
+    else
+    {
+        LE_WARN("Failed to start WiFi client command \"%s\" systemResult (%d)",
+                COMMAND_WIFI_HW_START, systemResult);
+        result = LE_FAULT;
     }
 
-
-    LE_INFO("WiFi client stopped correclty");
-    return LE_OK;
+    return result;
 }
 
 //--------------------------------------------------------------------------------------------------
@@ -370,16 +549,17 @@ le_result_t pa_wifiClient_Stop
     void
 )
 {
-    int status = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_STOP);
+    int systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFI_HW_STOP);
     /**
      * Returned values:
      *  0: if the interface is correctly unmounted
      * -1: if the fork() has failed (see man system)
      * 92: if unable to stop the interface
      */
-    if (!WIFEXITED(status) || (0 != WEXITSTATUS(status)))
+    if ((!WIFEXITED(systemResult)) || (0 != WEXITSTATUS(systemResult)))
     {
-        LE_ERROR("WiFi Client Command Failed: (%d)" COMMAND_WIFI_HW_STOP, status);
+        LE_ERROR("WiFi Client Command \"%s\" Failed: (%d)",
+                COMMAND_WIFI_HW_STOP, systemResult);
         return LE_FAULT;
     }
 
@@ -390,7 +570,7 @@ le_result_t pa_wifiClient_Stop
         return LE_FAULT;
     }
 
-    LE_INFO("WiFi client stopped correclty");
+    LE_DEBUG("WiFi client stopped correctly");
     return LE_OK;
 }
 
@@ -431,10 +611,10 @@ le_result_t pa_wifiClient_Scan
 
     if (NULL == IwScanPipePtr)
     {
-        LE_ERROR("Failed to run command: errno:%d: \"%s\" Cmd:"
-            COMMAND_WIFICLIENT_START_SCAN,
-            errno,
-            strerror(errno));
+        LE_ERROR("Failed to run command \"%s\": errno:%d: \"%s\" ",
+                COMMAND_WIFICLIENT_START_SCAN,
+                errno,
+                strerror(errno));
         result = LE_FAULT;
     }
 
@@ -452,6 +632,7 @@ le_result_t pa_wifiClient_Scan
 //--------------------------------------------------------------------------------------------------
 bool pa_wifiClient_IsScanRunning
 (
+    void
 )
 {
     return IsScanRunning;
@@ -470,10 +651,14 @@ bool pa_wifiClient_IsScanRunning
 //--------------------------------------------------------------------------------------------------
 le_result_t pa_wifiClient_GetScanResult
 (
-    pa_wifiClient_AccessPoint_t *accessPointPtr
+    pa_wifiClient_AccessPoint_t *accessPointPtr,
     ///< [IN][OUT]
     ///< Structure provided by calling function.
     ///< Results filled out if result was LE_OK.
+    char scanIfName[]
+    ///< [IN][OUT]
+    ///< Array provided by calling function.
+    ///< Store WLAN interface used for scan.
 )
 {
     const char bssidPrefix[] = "BSS ";
@@ -482,12 +667,14 @@ le_result_t pa_wifiClient_GetScanResult
     const unsigned int bssidPrefixLen = NUM_ARRAY_MEMBERS(bssidPrefix) - 1;
     const unsigned int ssidPrefixLen = NUM_ARRAY_MEMBERS(ssidPrefix) - 1;
     const unsigned int signalPrefixLen = NUM_ARRAY_MEMBERS(signalPrefix) - 1;
-    char path[1024];
+    char path[PATH_MAX_BYTES];
     struct timeval tv;
     fd_set fds;
     time_t start = time(NULL);
     le_result_t ret = LE_NOT_FOUND;
     int err;
+    char *retStart;
+    char *retEnd;
 
     LE_INFO("Scan results");
 
@@ -503,7 +690,7 @@ le_result_t pa_wifiClient_GetScanResult
     }
 
     /* Default values */
-    accessPointPtr->signalStrength = 0xffff;
+    accessPointPtr->signalStrength = LE_WIFICLIENT_NO_SIGNAL_STRENGTH;
     accessPointPtr->ssidLength = 0;
     memset(&accessPointPtr->ssidBytes, 0, LE_WIFIDEFS_MAX_SSID_BYTES);
     memset(&accessPointPtr->bssid, 0, LE_WIFIDEFS_MAX_BSSID_BYTES);
@@ -539,29 +726,44 @@ le_result_t pa_wifiClient_GetScanResult
             LE_DEBUG("Read next scan result");
             if (NULL != fgets(path, sizeof(path), IwScanPipePtr))
             {
-                LE_INFO("PARSING: '%s'", path);
+                LE_DEBUG("PARSING: '%s'", path);
 
                 if (0 == strncmp(ssidPrefix, path, ssidPrefixLen))
                 {
-                    accessPointPtr->ssidLength = strnlen(path, LE_WIFIDEFS_MAX_SSID_BYTES + ssidPrefixLen) - ssidPrefixLen - 1;
-                    LE_INFO("FOUND SSID: '%s'", &path[ssidPrefixLen]);
-                    memcpy(&accessPointPtr->ssidBytes, &path[ssidPrefixLen], accessPointPtr->ssidLength);
-                    LE_INFO("SSID: '%s'", &accessPointPtr->ssidBytes[0]);
+                    accessPointPtr->ssidLength =
+                    strnlen(path, LE_WIFIDEFS_MAX_SSID_BYTES + ssidPrefixLen) - ssidPrefixLen - 1;
+
+                    LE_DEBUG("FOUND SSID: '%s'", &path[ssidPrefixLen]);
+
+                    memcpy(&accessPointPtr->ssidBytes, &path[ssidPrefixLen],
+                           accessPointPtr->ssidLength);
+                    LE_DEBUG("SSID: '%s'", &accessPointPtr->ssidBytes[0]);
                     ret = LE_OK;
                     goto cleanup;
                 }
                 else if (0 == strncmp(signalPrefix, path, signalPrefixLen))
                 {
-                    LE_INFO("FOUND SIGNAL STRENGTH: '%s'", &path[signalPrefixLen]);
-                    accessPointPtr->signalStrength = atoi(&path[signalPrefixLen]);
-                    LE_INFO("signal(%d)",
-                    accessPointPtr->signalStrength);
+                    LE_DEBUG("FOUND SIGNAL STRENGTH: '%s'", &path[signalPrefixLen]);
+                    accessPointPtr->signalStrength = strtol(&path[signalPrefixLen], NULL, 10);
+                    LE_DEBUG("signal(%d)", accessPointPtr->signalStrength);
                 }
                 else if (0 == strncmp(bssidPrefix, path, bssidPrefixLen))
                 {
-                    LE_INFO("FOUND BSSID: '%s'", &path[bssidPrefixLen]);
-                    memcpy(&accessPointPtr->bssid, &path[bssidPrefixLen], LE_WIFIDEFS_MAX_BSSID_LENGTH);
-                    LE_INFO("BSSID: '%s'", &accessPointPtr->bssid[0]);
+                    LE_DEBUG("FOUND BSSID: '%s'", &path[bssidPrefixLen]);
+                    memcpy(&accessPointPtr->bssid, &path[bssidPrefixLen],
+                           LE_WIFIDEFS_MAX_BSSID_LENGTH);
+                    LE_DEBUG("BSSID: '%s'", &accessPointPtr->bssid[0]);
+                    if ('\0' == scanIfName[0])
+                    {
+                        if (NULL != (retStart = strstr(path, "wlan")) &&
+                            NULL != (retEnd = strchr(path, ')')))
+                            {
+                                strncpy(scanIfName, retStart, retEnd - retStart);
+                                scanIfName[LE_WIFIDEFS_MAX_IFNAME_LENGTH] = '\0';
+                                LE_DEBUG("Interface: '%s'", scanIfName);
+                            }
+
+                    }
                 }
             }
             else
@@ -630,7 +832,7 @@ le_result_t pa_wifiClient_SetSecurityProtocol
 {
     le_result_t result = LE_OK;
 
-    LE_INFO("Security protocol: %d", securityProtocol);
+    LE_DEBUG("Security protocol: %d", securityProtocol);
     switch (securityProtocol)
     {
         case LE_WIFICLIENT_SECURITY_NONE:
@@ -652,124 +854,57 @@ le_result_t pa_wifiClient_SetSecurityProtocol
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Compute the PSK from the SSID and the passphrase.
- *
- * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
- * @return LE_FAIL           The function failed.
- * @return LE_OK             The function succeeded.
+ * This function writes configurations to wpa_supplicant file.
  */
 //--------------------------------------------------------------------------------------------------
-static le_result_t GeneratePsk
+static le_result_t WriteClientCfgFile
 (
-    char *ssidBytesPtr,
-        ///< [IN]
-        ///< Contains ssidLength number of bytes
-    uint8_t ssidLength,
-        ///< [IN]
-        ///< The number of bytes in the ssidBytesPtr
-    char *passphrasePtr,
-        ///< [IN]
-        ///< The passphrase
-    char *pskPtr
-        ///< [OUT]
-        ///< The generated PSK
+    const char *dataPtr,
+    FILE *filePtr
 )
 {
-    char        tmpString[255];
-    le_result_t result         = LE_OK;
+    size_t length;
 
-    if (NULL == pskPtr)
-    {
-        LE_ERROR("Invalid PSK pointer");
-        return LE_BAD_PARAMETER;
-    }
-    if (NULL == passphrasePtr)
+    if ((NULL == filePtr) || (NULL == dataPtr))
     {
-        LE_ERROR("Invalid passphrase pointer");
-        return LE_BAD_PARAMETER;
+        LE_ERROR("Invalid parameter(s)");
+        return LE_FAULT;
     }
 
-    LE_INFO("Step 1: Generate Passphrase/PSK");
-    snprintf(tmpString,
-        sizeof(tmpString),
-        (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_WPA_PASSPHRASE),
-        ssidLength,
-        (char *)ssidBytesPtr,
-        passphrasePtr);
-
-    LE_INFO("Cmd: %s", tmpString);
-
-    // Open the command for reading.
-    IwConnectPipePtr = popen(tmpString, "r");
-
-    if (NULL == IwConnectPipePtr)
-    {
-        LE_ERROR("Failed to run command:\"%s\" errno:%d %s",
-            (tmpString),
-            errno,
-            strerror(errno));
-        result = LE_FAULT;
-    }
-    else
+    length = strlen(dataPtr);
+    if (length > 0)
     {
-        char path[255];
-
-        LE_INFO("Cmd successful: %s", tmpString);
-        // Read the output a line at a time - output it.
-        while (NULL != fgets(path, sizeof(path) - 1, IwConnectPipePtr))
+        if (fwrite(dataPtr, 1, length, filePtr) != length)
         {
-            LE_INFO("PARSING: len=%3d | %s", (int)strnlen(path, sizeof(path) - 1), path);
-            if (0 == strncmp("\tpsk=", path, strlen("\tpsk=")))
-            {
-                char     *p1Ptr = strchr(&path[5], '\n');
-                char     *p2Ptr = &path[5];
-                uint32_t  n     = p1Ptr - p2Ptr;
-
-                LE_INFO("FOUND  :%s", path);
-                memset(pskPtr, 0, LE_WIFIDEFS_MAX_PSK_BYTES);
-                if (n < LE_WIFIDEFS_MAX_PSK_BYTES)
-                {
-                    strncpy(pskPtr, &path[5], n);
-                    LE_INFO("PSK=%s | length: %d", pskPtr, n);
-                    result = LE_OK;
-                    break;
-                }
-                else
-                {
-                    LE_INFO("PSK length > %d", LE_WIFIDEFS_MAX_PSK_LENGTH);
-                    result = LE_FAULT;
-                }
-            }
+            LE_ERROR("Unable to write the wpa_supplicant file.");
+            return LE_FAULT;
         }
-        pclose(IwConnectPipePtr);
     }
 
-    return result;
+    return LE_OK;
 }
 
-
 //--------------------------------------------------------------------------------------------------
 /**
- * This function generates the WPA supplicant file.
+ * This function generates the WPA supplicant configuration file.
  */
 //--------------------------------------------------------------------------------------------------
 static le_result_t GenerateWpaSupplicant
 (
     char *ssidPtr,
-    const uint32_t ssidLength,
-    char *pskPtr
+    const uint32_t ssidLength
 )
 {
     FILE    *filePtr;
-    char     tmpString[255];
-    uint8_t  length;
+    char     tmpConfig[TEMP_CONFIG_MAX_BYTES];
+    char     tmpString[TEMP_STRING_MAX_BYTES];
 
-    LE_INFO("Step 2: SH script");
+    LE_DEBUG("Generate Wpa Supplicant");
 
-    // Check parameter
-    if ((ssidPtr == NULL) || (ssidLength == 0) || (ssidLength > LE_WIFIDEFS_MAX_SSID_LENGTH))
+    // Check SSID
+    if ((NULL == ssidPtr) || (0 == ssidLength) || (ssidLength > LE_WIFIDEFS_MAX_SSID_LENGTH))
     {
-        LE_ERROR("Invalid parameter(s)");
+        LE_ERROR("Invalid SSID");
         return LE_FAULT;
     }
 
@@ -777,32 +912,108 @@ static le_result_t GenerateWpaSupplicant
     filePtr = fopen(WPA_SUPPLICANT_FILE, "w");
     if (filePtr == NULL)
     {
-        LE_ERROR("Unable to create %s file.", WPA_SUPPLICANT_FILE);
+        LE_ERROR("Unable to create \"%s\" file.", WPA_SUPPLICANT_FILE);
         return LE_FAULT;
     }
 
-    if (pskPtr)
+    //used to store configuration to be written into wpa_supplicant.conf
+    memset(tmpConfig, '\0', sizeof(tmpConfig));
+    //used to store optional elements to be appended
+    memset(tmpString, '\0', sizeof(tmpString));
+    //common contents of wpa_supplicant.conf
+    snprintf(tmpConfig, sizeof(tmpConfig), WPA_SUPPLICANT_CONFIG_COMMON,
+             ssidLength, (char *)ssidPtr, HiddenAccessPoint);
+
+    //The common part and the security protocol part are written to wpa_supplicant.conf
+    //separately for easier debug.
+    tmpConfig[TEMP_CONFIG_MAX_BYTES - 1] = '\0';
+    if (LE_OK != WriteClientCfgFile(tmpConfig, filePtr))
     {
-        snprintf(tmpString, sizeof(tmpString), WPA_SUPPLICANT_DATA,
-                 strlen(ssidPtr), (char *)ssidPtr, HiddenAccessPoint, pskPtr);
+        LE_ERROR("Unable to write wpa_supplicant common part");
+        goto WRONG_CONFIG;
     }
-    else
+
+    memset(tmpConfig, '\0', sizeof(tmpConfig));
+    switch (SavedSecurityProtocol)
     {
-        snprintf(tmpString, sizeof(tmpString), WPA_SUPPLICANT_DATA_NO_SECURITY,
-                 strlen(ssidPtr), (char *)ssidPtr, HiddenAccessPoint);
+        case LE_WIFICLIENT_SECURITY_NONE:
+            le_utf8_Copy(tmpConfig, "key_mgmt=NONE\n", sizeof(tmpConfig), NULL);
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WEP:
+
+            if (0 == SavedWepKey[0])
+            {
+                LE_ERROR("No valid WEP key");
+                goto WRONG_CONFIG;
+            }
+            le_utf8_Copy(tmpConfig, "key_mgmt=NONE\n", sizeof(tmpConfig), NULL);
+            snprintf(tmpString, sizeof(tmpString), "wep_key0=\"%s\"\n", SavedWepKey);
+            le_utf8_Append(tmpConfig, tmpString, sizeof(tmpConfig), NULL);
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL:
+        case LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL:
+
+            if ((0 == SavedPassphrase[0]) && (0 == SavedPreSharedKey[0]))
+            {
+                LE_ERROR("No valid PassPhrase or PreSharedKey");
+                goto WRONG_CONFIG;
+            }
+            // Passphrase is set, generate psk here
+            if (0 != SavedPassphrase[0])
+            {
+                snprintf(tmpString, sizeof(tmpString), "psk=\"%s\"\n", SavedPassphrase);
+            }
+            else
+            {
+                snprintf(tmpString, sizeof(tmpString), "psk=%s\n", SavedPreSharedKey);
+            }
+            le_utf8_Copy(tmpConfig, tmpString, sizeof(tmpConfig), NULL);
+            break;
+
+        case LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE:
+        case LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE:
+
+            if ((0 == SavedUsername[0]) && (0 == SavedPassword[0]))
+            {
+                LE_ERROR("No valid Username or Password");
+                goto WRONG_CONFIG;
+            }
+            le_utf8_Copy(tmpConfig, "key_mgmt=WPA-EAP\n", sizeof(tmpConfig), NULL);
+            le_utf8_Append(tmpConfig, "eap=PEAP\n", sizeof(tmpConfig), NULL);
+            snprintf(tmpString, sizeof(tmpString), "identity=\"%s\"\n", SavedUsername);
+            le_utf8_Append(tmpConfig, tmpString, sizeof(tmpConfig), NULL);
+            memset(tmpString, '\0', sizeof(tmpString));
+            snprintf(tmpString, sizeof(tmpString), "password=\"%s\"\n", SavedPassword);
+            le_utf8_Append(tmpConfig, tmpString, sizeof(tmpConfig), NULL);
+            le_utf8_Append(tmpConfig, "phase1=\"peapver=0\"\n", sizeof(tmpConfig), NULL);
+            le_utf8_Append(tmpConfig, "phase2=\"auth=MSCHAPV2\"\n", sizeof(tmpConfig), NULL);
+            break;
+
+        default:
+            LE_ERROR("No valid Security Protocol");;
+            goto WRONG_CONFIG;
     }
 
-    length = strlen(tmpString);
+    // Append "}" to complete the network block
+    le_utf8_Append(tmpConfig, "}\n", sizeof(tmpConfig), NULL);
+    tmpConfig[TEMP_CONFIG_MAX_BYTES - 1] = '\0';
 
-    if (fwrite(&tmpString, 1, length, filePtr) != length)
+    if (LE_OK != WriteClientCfgFile(tmpConfig, filePtr))
     {
-        LE_ERROR("Unable to generate the WPA supplicant file (%s).", WPA_SUPPLICANT_FILE);
-        fclose(filePtr);
-        return LE_FAULT;
+        LE_ERROR("Unable to write wpa_supplicant security protocol part");
+        goto WRONG_CONFIG;
     }
 
     fclose(filePtr);
     return LE_OK;
+
+WRONG_CONFIG:
+
+    LE_ERROR("Unable to generate the WPA supplicant file \"%s\".", WPA_SUPPLICANT_FILE);
+    fclose(filePtr);
+    return LE_FAULT;
 }
 
 
@@ -810,8 +1021,11 @@ static le_result_t GenerateWpaSupplicant
 /**
  * This function connects a wifiClient.
  *
- * @return LE_FAULT  The function failed.
- * @return LE_OK     The function succeeded.
+ * @return LE_FAULT             The function failed.
+ * @return LE_BAD_PARAMETER     Invalid parameter.
+ * @return LE_DUPLICATE         Duplicated request.
+ * @return LE_TIMEOUT           Connection request time out.
+ * @return LE_OK                The function succeeded.
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t pa_wifiClient_Connect
@@ -825,268 +1039,53 @@ le_result_t pa_wifiClient_Connect
 )
 {
     int         systemResult;
-    char        tmpString[1024];
-    le_result_t result          = LE_OK;
-
-    LE_INFO("SSID length %d SSID: \"%.*s\"",
-        ssidLength,
-        ssidLength,
-        (char *)ssidBytes);
+    char        tmpString[TEMP_STRING_MAX_BYTES];
+    le_result_t result  = LE_OK;
 
-    if (0 == ssidLength)
+    // Check SSID
+    if (( 0 == ssidLength) || (ssidLength > LE_WIFIDEFS_MAX_SSID_LENGTH))
     {
         LE_ERROR("Invalid SSID");
-        return LE_FAULT;
+        return LE_BAD_PARAMETER;
     }
 
-    // Which type of WiFi client connection is requested?
-    switch (SavedSecurityProtocol)
-    {
-        case LE_WIFICLIENT_SECURITY_NONE:
-            // Opened WiFi hotspot (SSID with no password)
-            LE_INFO("SwitchCase: LE_WIFICLIENT_SECURITY_NONE");
-            // 1. Now WPA_CLI for LE_WIFICLIENT_SECURITY_NONE
-            LE_INFO("Step 2: SH script");
-            snprintf(tmpString,
-                sizeof(tmpString),
-                (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_NONE),
-                ssidLength,
-                (char *)ssidBytes,
-                HiddenAccessPoint);
-
-            systemResult = system(tmpString);
-            // Return value of -1 means that the fork() has failed (see man system).
-            if (0 == WEXITSTATUS(systemResult))
-            {
-                LE_INFO("WiFi Client Command OK: %s", tmpString);
-                result = LE_OK;
-            }
-            else
-            {
-                LE_ERROR("WiFi Client Command %s Failed: (%d)", tmpString, systemResult);
-                result = LE_FAULT;
-            }
-            break;
+    LE_INFO("Connecting over SSID length %d SSID: \"%.*s\"", ssidLength, ssidLength,
+            (char *)ssidBytes);
 
-        case LE_WIFICLIENT_SECURITY_WEP:
-            // Connect to secured network - WEP
-            LE_INFO("SwitchCase: LE_WIFICLIENT_SECURITY_WEP");
-            if (0 == SavedWepKey[0])
-            {
-                LE_ERROR("No valid WEP key");
-                return LE_FAULT;
-            }
-            // 1. WPA_CLI for LE_WIFICLIENT_SECURITY_WEP
-            if (LE_OK == result)
-            {
-                LE_INFO("Step 2: SH script");
-                snprintf(tmpString,
-                    sizeof(tmpString),
-                    (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WEP),
-                    ssidLength,
-                    (char *)ssidBytes,
-                    HiddenAccessPoint,
-                    SavedWepKey);
-
-                systemResult = system(tmpString);
-                // Return value of -1 means that the fork() has failed (see man system).
-                if (0 == WEXITSTATUS(systemResult))
-                {
-                    LE_INFO("WiFi Client Command OK: %s", tmpString);
-                    result = LE_OK;
-                }
-                else
-                {
-                    LE_ERROR("WiFi Client Command %s Failed: (%d)", tmpString, systemResult);
-                    result = LE_FAULT;
-                }
-            }
-            break;
-
-        case LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL:
-            // Connect to secured network - WPA
-            LE_INFO("SwitchCase: LE_WIFICLIENT_SECURITY_WPA_PSK_PERSONAL");
-            if ((0 == SavedPassphrase[0]) && (0 == SavedPreSharedKey[0]))
-            {
-                LE_ERROR("No valid PassPhrase or PreSharedKey");
-                return LE_FAULT;
-            }
-            // Passphrase is defined...
-            if (0 != SavedPassphrase[0])
-            {
-                // ... so the PSK is derived from it.
-                result = GeneratePsk((char *)&ssidBytes[0],
-                    ssidLength,
-                    (char *)&SavedPassphrase[0],
-                    (char *)&SavedPreSharedKey[0]);
-                if (LE_OK != result)
-                {
-                    LE_ERROR("No valid PassPhrase or PreSharedKey");
-                    return LE_FAULT;
-                }
-            }
-
-            if (LE_OK == result)
-            {
-                LE_INFO("Step 2: Generate WPA supplicant file");
-                // Generate the WPA supplicant file
-                if (GenerateWpaSupplicant((char *)&ssidBytes[0],
-                    ssidLength,
-                    (char *)&SavedPreSharedKey) == LE_OK)
-                {
-                    LE_INFO("Step 3: SH script");
-
-                    systemResult = system(WIFI_SCRIPT_PATH
-                        COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL);
-
-                    // Return value of -1 means that the fork() has failed (see man system).
-                    if (0 == WEXITSTATUS(systemResult))
-                    {
-                        LE_INFO("WiFi Client Command OK: %s",
-                            WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL);
-                        result = LE_OK;
-                    }
-                    else
-                    {
-                        LE_ERROR("WiFi Client Command %s Failed: (%d)",
-                            WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL,
-                            systemResult);
-                        result = LE_FAULT;
-                    }
-                }
-            }
-            break;
-
-        case LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL:
-            // Connect to secured network - WPA2
-            LE_INFO("SwitchCase: LE_WIFICLIENT_SECURITY_WPA2_PSK_PERSONAL");
-            if ((0 == SavedPassphrase[0]) && (0 == SavedPreSharedKey[0]))
-            {
-                LE_ERROR("No valid PassPhrase or PreSharedKey");
-                return LE_FAULT;
-            }
-            // Passphrase is defined...
-            if (0 != SavedPassphrase[0])
-            {
-                // ... so the PSK is derived from it.
-                result = GeneratePsk((char *)&ssidBytes[0],
-                    ssidLength,
-                    (char *)&SavedPassphrase,
-                    (char *)&SavedPreSharedKey);
-                if (LE_OK != result)
-                {
-                    LE_ERROR("No valid PassPhrase or PreSharedKey");
-                    return LE_FAULT;
-                }
-            }
-
-            if (LE_OK == result)
-            {
-                LE_INFO("Step 2: Generate WPA supplicant file");
-                // Generate the WPA supplicant file
-                if (GenerateWpaSupplicant((char *)&ssidBytes[0],
-                    ssidLength,
-                    (char *)&SavedPreSharedKey) == LE_OK)
-                {
-                    LE_INFO("Step 3: SH script");
-
-                    systemResult = system(WIFI_SCRIPT_PATH
-                        COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL);
-
-                    // Return value of -1 means that the fork() has failed (see man system).
-                    if (0 == WEXITSTATUS(systemResult))
-                    {
-                        LE_INFO("WiFi Client Command OK: %s",
-                            WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL);
-                        result = LE_OK;
-                    }
-                    else
-                    {
-                        LE_ERROR("WiFi Client Command %s Failed: (%d)",
-                            WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL,
-                            systemResult);
-                        result = LE_FAULT;
-                    }
-                }
-            }
-            break;
-
-        case LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE:
-            // Enterprise environment: connect to WPA EAP PEAP0
-            LE_INFO("SwitchCase: ..._SECURITY_WPA2_EAP_PEAP0_ENTERPRISE");
-            if ((0 == SavedUsername[0]) && (0 == SavedPassword[0]))
-            {
-                LE_ERROR("No valid Username & Password");
-                return LE_FAULT;
-            }
-            // 2. Now WPA_CLI for LE_WIFICLIENT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE
-            if (LE_OK == result)
-            {
-                LE_INFO("Step 2: SH script");
-                snprintf(tmpString,
-                    sizeof(tmpString),
-                    (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE),
-                    ssidLength,
-                    (char *)ssidBytes,
-                    HiddenAccessPoint,
-                    SavedUsername,
-                    SavedPassword);
-
-                systemResult = system(tmpString);
-                // Return value of -1 means that the fork() has failed (see man system).
-                if (0 == WEXITSTATUS(systemResult))
-                {
-                    LE_INFO("WiFi Client Command OK: %s", tmpString);
-                    result = LE_OK;
-                }
-                else
-                {
-                    LE_ERROR("WiFi Client Command %s Failed: (%d)", tmpString, systemResult);
-                    result = LE_FAULT;
-                }
-            }
-            break;
-
-        case LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE:
-            // Enterprise environment: connect to WPA2 EAP PEAP0
-            LE_INFO("SwitchCase: ..._SECURITY_WPA2_EAP_PEAP0_ENTERPRISE");
-            if ((0 == SavedUsername[0]) && (0 == SavedPassword[0]))
-            {
-                LE_ERROR("No valid Username & Password");
-                return LE_FAULT;
-            }
-            // 2. Now WPA_CLI for LE_WIFICLIENT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE
-            if (LE_OK == result)
-            {
-                LE_INFO("Step 2: SH script");
-                snprintf(tmpString,
-                    sizeof(tmpString),
-                    (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE),
-                    ssidLength,
-                    (char *)ssidBytes,
-                    HiddenAccessPoint,
-                    SavedUsername,
-                    SavedPassword);
-
-                systemResult = system(tmpString);
-                // Return value of -1 means that the fork() has failed (see man system).
-                if (0 == WEXITSTATUS(systemResult))
-                {
-                    LE_INFO("WiFi Client Command OK: %s", tmpString);
-                    result = LE_OK;
-                }
-                else
-                {
-                    LE_ERROR("WiFi Client Command %s Failed: (%d)", tmpString, systemResult);
-                    result = LE_FAULT;
-                }
-            }
-            break;
+    if (LE_OK != GenerateWpaSupplicant((char *)&ssidBytes[0], ssidLength))
+    {
+        return LE_BAD_PARAMETER;
+    }
+    le_utf8_Copy(tmpString, WIFI_SCRIPT_PATH, sizeof(tmpString), NULL);
+    le_utf8_Append(tmpString, COMMAND_WIFICLIENT_CONNECT, sizeof(tmpString), NULL);
+    le_utf8_Append(tmpString, WPA_SUPPLICANT_FILE, sizeof(tmpString), NULL);
 
-        default:
-            result = LE_FAULT;
-            break;
+    systemResult = system(tmpString);
+    // Return value of 0 means WiFi client connected.
+    if (0 == WEXITSTATUS(systemResult))
+    {
+        LE_DEBUG("WiFi Client connected");
+        result = LE_OK;
+    }
+    // Return value of 8 means connection time out.
+    else if ( PA_TIMEOUT == WEXITSTATUS(systemResult))
+    {
+        LE_DEBUG("Connection time out");
+        result = LE_TIMEOUT;
+    }
+    // Return value of 14 means wpa_supplicant is running.
+    else if ( PA_DUPLICATE == WEXITSTATUS(systemResult))
+    {
+        LE_WARN("WPA_SUPPLICANT is running already");
+        result = LE_DUPLICATE;
     }
+    // Return value of -1 means that the fork() has failed (see man system).
+    else
+    {
+        LE_ERROR("WiFi Client Command %s Failed: (%d)", tmpString, systemResult);
+        result = LE_FAULT;
+    }
+
     return result;
 }
 
@@ -1110,12 +1109,13 @@ le_result_t pa_wifiClient_Disconnect
     systemResult = system(WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_DISCONNECT);
     if (0 == WEXITSTATUS(systemResult))
     {
-        LE_INFO("WiFi Client Command OK:" COMMAND_WIFICLIENT_DISCONNECT);
+        LE_INFO("WiFi Client Command \"%s\" OK:", COMMAND_WIFICLIENT_DISCONNECT);
         result = LE_OK;
     }
     else
     {
-        LE_ERROR("WiFi Client Command Failed: (%d)" COMMAND_WIFICLIENT_DISCONNECT, systemResult);
+        LE_ERROR("WiFi Client Command \"%s\" Failed: (%d)",
+                COMMAND_WIFICLIENT_DISCONNECT, systemResult);
         result = LE_FAULT;
     }
     return result;
@@ -1165,7 +1165,7 @@ le_result_t pa_wifiClient_SetWepKey
 {
     le_result_t result = LE_BAD_PARAMETER;
 
-    LE_INFO("Set WEP key");
+    LE_DEBUG("Set WEP key");
     if (NULL != wepKeyPtr)
     {
        strncpy(&SavedWepKey[0], &wepKeyPtr[0], LE_WIFIDEFS_MAX_WEPKEY_LENGTH);
@@ -1195,7 +1195,7 @@ le_result_t pa_wifiClient_SetPreSharedKey
 {
     le_result_t result = LE_BAD_PARAMETER;
 
-    LE_INFO("Set PSK");
+    LE_DEBUG("Set PSK");
     if (NULL != preSharedKeyPtr)
     {
        strncpy(&SavedPreSharedKey[0], &preSharedKeyPtr[0], LE_WIFIDEFS_MAX_PSK_LENGTH);
@@ -1225,7 +1225,7 @@ void pa_wifiClient_SetHiddenNetworkAttribute
         ///< If TRUE, the WIFI client will be able to connect to a hidden access point.
 )
 {
-    LE_INFO("Set whether Access Point is hidden or not: %d", hidden);
+    LE_DEBUG("Set whether Access Point is hidden or not: %d", hidden);
     HiddenAccessPoint = hidden;
 }
 
@@ -1250,12 +1250,12 @@ le_result_t pa_wifiClient_SetPassphrase
     // Store Passphrase to be used later during connection procedure
     le_result_t result = LE_BAD_PARAMETER;
 
-    LE_INFO("Set passphrase");
+    LE_DEBUG("Set passphrase");
     if (NULL != passphrasePtr)
     {
         length = strlen(passphrasePtr);
 
-        LE_INFO("Set passphrase");
+        LE_DEBUG("Set passphrase");
         if ((LE_WIFIDEFS_MIN_PASSPHRASE_LENGTH <= length) &&
             (length <= LE_WIFIDEFS_MAX_PASSPHRASE_LENGTH))
         {
@@ -1296,15 +1296,12 @@ le_result_t pa_wifiClient_SetUserCredentials
 )
 {
     // Store User Credentials to be used later during connection procedure
-    le_result_t result = LE_BAD_PARAMETER;
-
-    LE_INFO("Set user credentials");
+    LE_DEBUG("Set user credentials");
     if (NULL != usernamePtr)
     {
        strncpy(&SavedUsername[0], &usernamePtr[0], LE_WIFIDEFS_MAX_USERNAME_LENGTH);
        // Make sure there is a null termination
        SavedUsername[LE_WIFIDEFS_MAX_USERNAME_LENGTH] = '\0';
-       result = LE_OK;
     }
     else
     {
@@ -1316,21 +1313,22 @@ le_result_t pa_wifiClient_SetUserCredentials
        strncpy(&SavedPassword[0], &passwordPtr[0], LE_WIFIDEFS_MAX_PASSWORD_LENGTH);
        // Make sure there is a null termination
        SavedPassword[LE_WIFIDEFS_MAX_PASSWORD_LENGTH] = '\0';
-       result = LE_OK;
     }
     else
     {
         return LE_BAD_PARAMETER;
     }
-    return result;
+    return LE_OK;
 }
 
 //--------------------------------------------------------------------------------------------------
 /**
  * Add handler function for PA EVENT 'le_wifiClient_Event_t'
- *
  * This event provide information on PA WiFi Client event changes.
  *
+ * @deprecated pa_wifiClient_AddEventHandler() should not be used anymore.
+ * It has been replaced by pa_wifiClient_AddEventIndHandler().
+ *
  * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
  * @return LE_OK             The function succeeded.
  */
@@ -1349,12 +1347,48 @@ le_result_t pa_wifiClient_AddEventHandler
     le_event_HandlerRef_t handlerRef;
 
     handlerRef = le_event_AddLayeredHandler("WifiClientPaHandler",
-        WifiClientPaEvent,
-        FirstLayerWifiClientEventHandler,
-        (le_event_HandlerFunc_t)handlerPtr);
+                                    WifiClientPaEvent,
+                                    FirstLayerWifiClientEventHandler,
+                                    (le_event_HandlerFunc_t)handlerPtr);
+    if (NULL == handlerRef)
+    {
+        LE_ERROR("le_event_AddLayeredHandler returned NULL");
+        return LE_BAD_PARAMETER;
+    }
+    le_event_SetContextPtr(handlerRef, contextPtr);
+    return LE_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Add handler function for PA EVENT 'le_wifiClient_EventInd_t'
+ *
+ * This event provide information on PA WiFi Client event changes.
+ *
+ * @return LE_BAD_PARAMETER  The function failed due to an invalid parameter.
+ * @return LE_OK             The function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiClient_AddEventIndHandler
+(
+    pa_wifiClient_EventIndHandlerFunc_t handlerPtr,
+        ///< [IN]
+        ///< Event handler function pointer.
+
+    void *contextPtr
+        ///< [IN]
+        ///< Associated event context.
+)
+{
+    le_event_HandlerRef_t handlerRef;
+
+    handlerRef = le_event_AddLayeredHandler("WifiClientPaHandler",
+                                    WifiClientPaEventId,
+                                    FirstLayerWifiClientEventIndHandler,
+                                   (le_event_HandlerFunc_t)handlerPtr);
     if (NULL == handlerRef)
     {
-        LE_INFO("ERROR: le_event_AddLayeredHandler returned NULL");
+        LE_ERROR("le_event_AddLayeredHandler returned NULL");
         return LE_BAD_PARAMETER;
     }
     le_event_SetContextPtr(handlerRef, contextPtr);
diff --git a/service/platformAdaptor/inc/pa_wifi.h b/service/platformAdaptor/inc/pa_wifi.h
index 29d8123..431ee36 100644
--- a/service/platformAdaptor/inc/pa_wifi.h
+++ b/service/platformAdaptor/inc/pa_wifi.h
@@ -12,6 +12,19 @@
 #include "legato.h"
 #include "interfaces.h"
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Return value from WiFi platform adapter code.
+ * 8 is returned if WiFi connection can not be established within a given time
+ * 14 is returned if wpa_supplicant is running
+ * 50 is returned if WiFi hardware is absent.
+ * 100 is returned if WiFi driver can not be installed.
+ */
+//--------------------------------------------------------------------------------------------------
+#define PA_TIMEOUT          8
+#define PA_DUPLICATE        14
+#define PA_NOT_FOUND        50
+#define PA_NOT_POSSIBLE     100
 //--------------------------------------------------------------------------------------------------
 /**
  * AccessPoint structure.
@@ -19,7 +32,8 @@
 //--------------------------------------------------------------------------------------------------
 typedef struct
 {
-    int16_t  signalStrength;                        ///< 0xffff means value was not found.
+    int16_t  signalStrength;                        ///< LE_WIFICLIENT_NO_SIGNAL_STRENGTH means
+                                                    ///< value was not found.
     uint8_t  ssidLength;                            ///< The number of bytes in the ssidBytes.
     uint8_t  ssidBytes[LE_WIFIDEFS_MAX_SSID_BYTES]; ///< Contains ssidLength number of bytes.
     char     bssid[LE_WIFIDEFS_MAX_BSSID_BYTES];    ///< Contains the bssid.
@@ -30,6 +44,9 @@ typedef struct
  * Event handler for PA WiFi access point changes.
  *
  * Handles the PA WiFi events.
+ *
+ * @deprecated pa_wifiClient_AddEventHandler() should not be used anymore.
+ * It has been replaced by pa_wifiClient_AddEventIndHandler().
  */
 //--------------------------------------------------------------------------------------------------
 typedef void (*pa_wifiClient_NewEventHandlerFunc_t)
@@ -47,6 +64,9 @@ typedef void (*pa_wifiClient_NewEventHandlerFunc_t)
  * Add handler function for PA EVENT 'le_wifiClient_Event_t'
  *
  * This event provides information on PA WiFi Client event changes.
+ *
+ * @deprecated pa_wifiClient_AddEventHandler() should not be used anymore.
+ * It has been replaced by pa_wifiClient_AddEventIndHandler().
  */
 //--------------------------------------------------------------------------------------------------
 LE_SHARED le_result_t pa_wifiClient_AddEventHandler
@@ -59,6 +79,40 @@ LE_SHARED le_result_t pa_wifiClient_AddEventHandler
         ///< Associated event context.
 );
 
+//--------------------------------------------------------------------------------------------------
+/**
+ * Event handler for PA WiFi connection changes.
+ *
+ * Handles the PA WiFi events.
+ */
+//--------------------------------------------------------------------------------------------------
+typedef void (*pa_wifiClient_EventIndHandlerFunc_t)
+(
+    le_wifiClient_EventInd_t* wifiEventIndPtr,
+        ///< [IN]
+        ///< WiFi event pointer to process
+    void *contextPtr
+        ///< [IN]
+        ///< Associated WiFi event context
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Add handler function for PA EVENT 'le_wifiClient_EventInd_t'
+ *
+ * This event provides information on PA WiFi Client event changes.
+ */
+//--------------------------------------------------------------------------------------------------
+LE_SHARED le_result_t pa_wifiClient_AddEventIndHandler
+(
+    pa_wifiClient_EventIndHandlerFunc_t handlerPtr,
+        ///< [IN]
+        ///< Event handler function pointer.
+    void *contextPtr
+        ///< [IN]
+        ///< Associated event context.
+);
+
 //--------------------------------------------------------------------------------------------------
 /**
  * This function must be called to initialize the PA WiFi Module.
@@ -120,16 +174,20 @@ LE_SHARED bool pa_wifiClient_IsScanRunning
  * pa_wifiClient_ScanDone MUST be called.
  *
  * @return LE_NOT_FOUND  There is no more AP found.
- * @return LE_OK     The function succeeded.
- * @return LE_FAULT  The function failed.
+ * @return LE_OK         The function succeeded.
+ * @return LE_FAULT      The function failed.
  */
 //--------------------------------------------------------------------------------------------------
 LE_SHARED le_result_t pa_wifiClient_GetScanResult
 (
-    pa_wifiClient_AccessPoint_t *accessPointPtr
+    pa_wifiClient_AccessPoint_t *accessPointPtr,
     ///< [IN][OUT]
     ///< Structure provided by calling function.
     ///< Results filled out if result was LE_OK.
+    char scanIfName[]
+    ///< [IN][OUT]
+    ///< Array provided by calling function.
+    ///< Store WLAN interface used for scan.
 );
 
 //--------------------------------------------------------------------------------------------------
@@ -150,8 +208,11 @@ LE_SHARED le_result_t pa_wifiClient_ScanDone
 /**
  * This function connects a wifiClient.
  *
- * @return LE_FAULT  The function failed.
- * @return LE_OK     The function succeeded.
+ * @return LE_FAULT             The function failed.
+ * @return LE_BAD_PARAMETER     Invalid parameter.
+ * @return LE_DUPLICATE         Duplicated request.
+ * @return LE_TIMEOUT           Connection request time out.
+ * @return LE_OK                The function succeeded.
  */
 //--------------------------------------------------------------------------------------------------
 LE_SHARED le_result_t pa_wifiClient_Connect
@@ -294,8 +355,10 @@ LE_SHARED le_result_t pa_wifiClient_ClearAllCredentials
 /**
  * Start WiFi Client PA
  *
- * @return LE_FAULT  The function failed.
- * @return LE_OK     The function succeeded.
+ * @return LE_FAULT         The function failed.
+ * @return LE_OK            The function succeeded.
+ * @return LE_NOT_FOUND     The WiFi card is absent.
+ * @return LE_NOT_POSSIBLE  The WiFi card may not work.
  */
 //--------------------------------------------------------------------------------------------------
 LE_SHARED le_result_t pa_wifiClient_Start
diff --git a/service/platformAdaptor/inc/pa_wifi_ap.h b/service/platformAdaptor/inc/pa_wifi_ap.h
index cadaa53..f420637 100644
--- a/service/platformAdaptor/inc/pa_wifi_ap.h
+++ b/service/platformAdaptor/inc/pa_wifi_ap.h
@@ -10,7 +10,15 @@
 // -------------------------------------------------------------------------------------------------
 #include "legato.h"
 #include "interfaces.h"
-
+//--------------------------------------------------------------------------------------------------
+/**
+ * Return value from WiFi platform adapter scripts code.
+ * 50 is returned if WiFi hardware is absent.
+ * 100 is returned if WiFi driver can not be installed.
+ */
+//--------------------------------------------------------------------------------------------------
+#define PA_NOT_FOUND        50
+#define PA_NOT_POSSIBLE     100
 //--------------------------------------------------------------------------------------------------
 /**
  * Event handler for PA WiFi access point changes.
@@ -80,6 +88,8 @@ LE_SHARED le_result_t pa_wifiAp_Release
  *
  * @return LE_FAULT         The function failed.
  * @return LE_OK            The function succeeded.
+ * @return LE_NOT_FOUND     The WiFi card is absent.
+ * @return LE_NOT_POSSIBLE  The WiFi card may not work.
  *
  */
 //--------------------------------------------------------------------------------------------------
@@ -198,20 +208,77 @@ le_result_t pa_wifiAp_SetDiscoverable
 
 //--------------------------------------------------------------------------------------------------
 /**
- * Set the WiFi channel to use.
- * Default value is 1.
- * Some legal restrictions for values 12 - 14 might apply for your region.
+ * Set which IEEE standard to use.
+ * Default hardware mode is IEEE 802.11g.
+ *
+ * @return
+ *      - LE_BAD_PARAMETER if invalid IEEE standard is set.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiAp_SetIeeeStandard
+(
+    le_wifiAp_IeeeStdBitMask_t stdMask
+        ///< [IN]
+        ///< Bit mask for the IEEE standard.
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Get which IEEE standard was set.
+ * Default hardware mode is IEEE 802.11g.
+ *
+ * @return
+ *      - LE_FAULT if the function failed.
+ *      - LE_OK if the function succeeded.
+ *
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiAp_GetIeeeStandard
+(
+    le_wifiAp_IeeeStdBitMask_t *stdMaskPtr
+        ///< [OUT]
+        ///< Bit mask for the IEEE standard.
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set what country code to use for regulatory domain.
+ * ISO/IEC 3166-1 Alpha-2 code is used.
+ * Default country code is US.
+ * @return
+ *      - LE_FAULT if the function failed.
+ *      - LE_OK if the function succeeded.
  *
- * @return LE_OUT_OF_RANGE Requested channel number is out of range.
- * @return LE_OK           Function succeeded.
+ */
+//--------------------------------------------------------------------------------------------------
+le_result_t pa_wifiAp_SetCountryCode
+(
+    const char *countryCodePtr
+        ///< [IN]
+        ///< the country code.
+);
+
+//--------------------------------------------------------------------------------------------------
+/**
+ * Set which WiFi channel to use.
+ * Default number is 7.
+ * Some legal restrictions might apply for your region.
+ * The channel number must be between 1 and 14 for IEEE 802.11b/g.
+ * The channel number must be between 7 and 196 for IEEE 802.11a.
+ * The channel number must be between 1 and 6 for IEEE 802.11ad.
+ * @return
+ *      - LE_OUT_OF_RANGE if requested channel number is out of range.
+ *      - LE_OK if the function succeeded.
  *
  */
 //--------------------------------------------------------------------------------------------------
 le_result_t pa_wifiAp_SetChannel
 (
-    int8_t channelNumber
+    uint16_t channelNumber
         ///< [IN]
-        ///< the channel number must be between 1 and 14.
+        ///< the channel number.
 );
 
 //--------------------------------------------------------------------------------------------------
diff --git a/service/platformAdaptor/qca/pa_wifi.sh b/service/platformAdaptor/qca/pa_wifi.sh
new file mode 100644
index 0000000..03a9378
--- /dev/null
+++ b/service/platformAdaptor/qca/pa_wifi.sh
@@ -0,0 +1,179 @@
+#!/bin/sh
+# Copyright (C) Sierra Wireless Inc.
+#
+# ($1:) -d Debug logs
+# $1: Command (ex:  WIFI_START
+#                   WIFICLIENT_CONNECT
+# $2: wpa_supplicant.conf file directory
+
+if [ "$1" = "-d" ]; then
+    shift
+    set -x
+fi
+
+CMD=$1
+# WiFi interface
+IFACE=wlan0
+# If WLAN interface does not exist but driver is installed, means WiFi hardware is absent
+HARDWAREABSENCE=50
+# QCA wifi module name
+QCAWIFIMOD=wlan
+# If wpa_supplicant is running already
+WPADUPLICATE=14
+# WiFi driver is not installed
+NODRIVER=100
+TIMEOUT=8
+SUCCESS=0
+ERROR=127
+# PATH
+export PATH=/legato/systems/current/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
+
+# Check the connection on the WiFi network interface.
+# Exit with 0 if connected otherwise exit with 8 (time out)
+CheckConnection()
+{
+    retries=10
+    echo "Checking connection..."
+    # Verify connection status
+    for i in $(seq 1 ${retries})
+    do
+        echo "loop=${i}"
+        (/usr/sbin/iw ${IFACE} link | grep "Connected to") && break
+        sleep 1
+    done
+    if [ "${i}" -eq "${retries}" ]; then
+        # Connection request time out.
+        exit ${TIMEOUT}
+    fi
+    # Connected.
+    exit ${SUCCESS}
+}
+
+echo "${CMD}"
+case ${CMD} in
+    WIFI_START)
+        retries=10
+        # Do clean up, even just after reboot
+        /usr/bin/qca9377 wifi client stop > /dev/null 2>&1
+        sleep 1
+        # Run wifi start background
+        /usr/bin/qca9377 wifi client init > /dev/null 2>&1 &
+        for i in $(seq 1 ${retries})
+        do
+            echo "loop=${i}"
+            sleep 1
+            [ -e /sys/class/net/${IFACE} ] && break
+        done
+        if [ "${i}" -ne "${retries}" ]; then
+            /sbin/ifconfig ${IFACE} up
+            exit ${SUCCESS}
+        fi
+        moduleString=$(/sbin/lsmod | grep ${QCAWIFIMOD}) > /dev/null
+        if [ -n "${moduleString}" ]; then
+            ret=${HARDWAREABSENCE}
+        else
+            ret=${ERROR}
+        fi
+        # Do clean up
+        /usr/bin/qca9377 wifi client stop > /dev/null 2>&1
+        exit ${ret} ;;
+
+  WIFI_STOP)
+    # If wpa_supplicant is still running, terminate it
+    (/bin/ps -ax | grep wpa_supplicant | grep ${IFACE} >/dev/null 2>&1) \
+    && /sbin/wpa_cli -i${IFACE} terminate
+    # Unmount the WiFi network interface
+    /usr/bin/qca9377 wifi client stop > /dev/null 2>&1 || exit ${ERROR}
+    ;;
+
+  WIFI_SET_EVENT)
+    /usr/sbin/iw event || exit ${ERROR}
+    ;;
+
+  WIFI_UNSET_EVENT)
+    count=$(/usr/bin/pgrep -c iw)
+    [ "${count}" -eq 0 ] && exit ${SUCCESS}
+    for i in $(seq 1 "${count}")
+    do
+        pid=$(/usr/bin/pgrep -n iw)
+        /bin/kill -9 "${pid}"
+    done
+    count=$(/usr/bin/pgrep -c iw)
+    [ "${count}" -eq 0 ] || exit ${ERROR}
+    ;;
+
+  WIFI_CHECK_HWSTATUS)
+    #Client request disconnection if interface in up
+    /sbin/ifconfig | grep ${IFACE} > /dev/null 2>&1
+    [ $? -eq 0 ] && exit ${SUCCESS}
+    sleep 1
+    #Check WiFi stop called or not
+    /sbin/lsmod | grep ${QCAWIFIMOD} > /dev/null 2>&1
+    #Driver stays, hardware removed
+    [ $? -eq 0 ] && exit ${HARDWAREABSENCE}
+    #WiFi stop called
+    exit ${NODRIVER} ;;
+
+  WIFIAP_HOSTAPD_START)
+    (/bin/hostapd /tmp/hostapd.conf -i${IFACE} -B) && exit ${SUCCESS}
+    # Fail to start hostapd, do cleanup
+    /usr/bin/qca9377 wifi client stop
+    exit ${ERROR} ;;
+
+  WIFIAP_HOSTAPD_STOP)
+    rm -f /tmp/dnsmasq.wlan.conf
+    touch /tmp/dnsmasq.wlan.conf
+    /etc/init.d/dnsmasq stop
+    killall hostapd
+    sleep 1;
+    pidof hostapd && (kill -9 "$(pidof hostapd)" || exit ${ERROR})
+    pidof dnsmasq && (kill -9 "$(pidof dnsmasq)" || exit ${ERROR})
+    /etc/init.d/dnsmasq start || exit ${ERROR}
+    ;;
+
+  WIFIAP_WLAN_UP)
+    AP_IP=$2
+    /sbin/ifconfig | grep ${IFACE} || exit ${ERROR}
+    /sbin/ifconfig ${IFACE} "${AP_IP}" up || exit ${ERROR}
+    ;;
+
+  DNSMASQ_RESTART)
+    echo "interface=${IFACE}" >> /tmp/dnsmasq.wlan.conf
+    /etc/init.d/dnsmasq stop
+    pkill -9 dnsmasq
+    /etc/init.d/dnsmasq start || exit ${ERROR}
+    ;;
+
+  WIFICLIENT_START_SCAN)
+    (/usr/sbin/iw dev ${IFACE} scan | grep 'BSS\|SSID\|signal') || exit ${ERROR}
+    ;;
+
+  WIFICLIENT_CONNECT)
+    WPA_CFG=$2
+    [ -f "${WPA_CFG}" ] || exit ${ERROR}
+    # wpa_supplicant is running, return duplicated request
+    /bin/ps -A | grep wpa_supplicant && exit ${WPADUPLICATE}
+    /sbin/wpa_supplicant -d -Dnl80211 -c "${WPA_CFG}" -i${IFACE} -B || exit ${ERROR}
+    CheckConnection ;;
+
+  WIFICLIENT_DISCONNECT)
+    /sbin/wpa_cli -i${IFACE} terminate || exit ${ERROR}
+    echo "WiFi client disconnected."
+    ;;
+
+  IPTABLE_DHCP_INSERT)
+    /usr/sbin/iptables -I INPUT -i ${IFACE} -p udp -m udp \
+     --sport 67:68 --dport 67:68 -j ACCEPT  || exit ${ERROR}
+    ;;
+
+  IPTABLE_DHCP_DELETE)
+    /usr/sbin/iptables -D INPUT -i ${IFACE} -p udp -m udp \
+     --sport 67:68 --dport 67:68 -j ACCEPT  || exit ${ERROR}
+    ;;
+
+  *)
+    echo "Parameter not valid"
+    exit ${ERROR} ;;
+esac
+exit ${SUCCESS}
+
diff --git a/service/platformAdaptor/ti/pa_wifi.sh b/service/platformAdaptor/ti/pa_wifi.sh
index 0a0b472..623f42c 100644
--- a/service/platformAdaptor/ti/pa_wifi.sh
+++ b/service/platformAdaptor/ti/pa_wifi.sh
@@ -2,252 +2,194 @@
 # Copyright (C) Sierra Wireless Inc.
 #
 # ($1:) -d Debug logs
-# $1: wlan interface (ex: wlan0)
-# $2: Command (ex:  WIFI_START
-#           WIFI_STOP
-#           WIFICLIENT_CONNECT_SECURITY_NONE
-#           WIFICLIENT_CONNECT_SECURITY_WEP
-#           WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL
-#           WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL
-#           WIFICLIENT_CONNECT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE
-#           WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE
-# $3: SSID
-# $4: HiddenAP (this parameter should be set when the AP is hidden from scan)
-# $5: WEP key or WPAx_EAP_PEAP0_ENTERPRISE identity
-# $6: WPAx_EAP_PEAP0_ENTERPRISE password
+# $1: Command (ex:  WIFI_START
+#                   WIFICLIENT_CONNECT
+# $2: wpa_supplicant.conf file directory
 
 if [ "$1" = "-d" ]; then
     shift
     set -x
 fi
 
+CMD=$1
 # WiFi interface
-IFACE=$1
-CMD=$2
-SSID=$3
-
-# Configuration file
-WPA_CFG=wpa_supplicant.conf
-
+IFACE=wlan0
+# If WLAN interface exists but can not be brought up, means WiFi hardware is inserted,
+# drivers are loaded successfully, but firmware failed to boot, tiwifi.sh returns 100
+FIRMWAREFAILURE=100
+# If WLAN interface does not exist but driver is installed, means WiFi hardware is absent
+HARDWAREABSENCE=50
+# WiFi driver is not installed
+NODRIVER=100
+TIMEOUT=8
 # PATH
 export PATH=/legato/systems/current/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
 
 # Check the connection on the WiFi network interface.
-# Exit with 0 if connected otherwise exit with 30 (number of retries)
+# Exit with 0 if connected otherwise exit with 8 (time out)
 CheckConnection()
 {
-    retries=25
+    local retries=10
     echo "Checking connection..."
     # Verify connection status
     for i in $(seq 1 ${retries})
     do
-      echo "loop=${i}"
-      (/usr/sbin/iw $1 link | grep "Connected to") && break
-      sleep 1
+        echo "loop=${i}"
+        (/usr/sbin/iw $1 link | grep "Connected to") && break
+        sleep 1
     done
     if [ "${i}" -eq "${retries}" ]; then
-        exit ${retries}
+        # Connection request time out.
+        exit ${TIMEOUT}
     fi
+    # Connected.
     exit 0
 }
 
+WiFiReset()
+{
+    local retries=3
+    echo "WiFi reset"
+    for i in $(seq 1 ${retries})
+    do
+        sleep 1
+        /etc/init.d/tiwifi stop
+        sleep 1
+        /etc/init.d/tiwifi start && exit 0
+    done
+    exit 127
+}
+
 case ${CMD} in
   WIFI_START)
     echo "WIFI_START"
     # Mount the WiFi network interface
-    /sbin/ifup ${IFACE} || exit 91
-    exit 0 ;;
+    /etc/init.d/tiwifi start && exit 0
+    # Store failure reason
+    FAILUREREASON=$?
+    # If tiwifi.sh indicates firmware fails to boot, do reset
+    if [ ${FAILUREREASON} -eq ${FIRMWAREFAILURE} ]; then
+        WiFiReset && exit 0
+        # Reset fail, do clean up
+        /etc/init.d/tiwifi stop
+        exit ${FAILUREREASON}
+    fi
+    # Hardware is absent, do clean up
+    if [ ${FAILUREREASON} -eq ${HARDWAREABSENCE} ]; then
+        /etc/init.d/tiwifi stop
+        exit ${FAILUREREASON}
+    fi
+    # Other reasons, do clean up also
+    /etc/init.d/tiwifi stop
+    exit ${FAILUREREASON} ;;
 
   WIFI_STOP)
     echo "WIFI_STOP"
+    # If wpa_supplicant is still running, terminate it
+    (/bin/ps -ax | grep wpa_supplicant | grep ${IFACE} >/dev/null 2>&1) \
+    && /sbin/wpa_cli -i${IFACE} terminate
     # Unmount the WiFi network interface
-    /sbin/ifdown ${IFACE}
-    [ $? -ne 0 ] && exit 92
+    /etc/init.d/tiwifi stop || exit 127
     exit 0 ;;
 
-  WIFI_WLAN_UP)
-    echo "WIFI_WLAN_UP"
+  WIFI_SET_EVENT)
+    echo "WIFI_SET_EVENT"
+    /usr/sbin/iw event || exit 127
     exit 0 ;;
 
-  WIFI_WLAN_DOWN)
-    echo "WIFI_WLAN_DOWN"
+  WIFI_UNSET_EVENT)
+    echo "WIFI_UNSET_EVENT"
+    count=$(/usr/bin/pgrep -c iw)
+    [ "${count}" -eq 0 ] && exit 0
+    for i in $(seq 1 ${count})
+    do
+        pid=$(/usr/bin/pgrep -n iw)
+        /bin/kill -9 ${pid}
+    done
+    count=$(/usr/bin/pgrep -c iw)
+    [ "${count}" -eq 0 ] || exit 127
     exit 0 ;;
 
-  WIFI_SET_EVENT)
-    echo "WIFI_SET_EVENT"
-    /usr/sbin/iw event || exit 94
-    exit 0 ;;
+  WIFI_CHECK_HWSTATUS)
+    echo "WIFI_CHECK_HWSTATUS"
+    #Client request disconnection if interface in up
+    /sbin/ifconfig | grep ${IFACE} >/dev/null
+    [ $? -eq 0 ] && exit 0
+    sleep 1
+    #Check WiFi stop called or not
+    /sbin/lsmod | grep wlcore >/dev/null
+    #Driver stays, hardware removed
+    [ $? -eq 0 ] && exit ${HARDWAREABSENCE}
+    #WiFi stop called
+    exit ${NODRIVER} ;;
 
   WIFIAP_HOSTAPD_START)
     echo "WIFIAP_HOSTAPD_START"
-    (/bin/hostapd /tmp/hostapd.conf &)|| exit 95
-    exit 0 ;;
+    (/bin/hostapd /tmp/hostapd.conf -i${IFACE} -B) && exit 0
+    # Fail to start hostapd, do cleanup
+    /etc/init.d/tiwifi stop
+    exit 127 ;;
 
   WIFIAP_HOSTAPD_STOP)
     echo "WIFIAP_HOSTAPD_STOP"
-    rm -f /tmp/dnsmasq.wlan.conf; touch /tmp/dnsmasq.wlan.conf
+    rm -f /tmp/dnsmasq.wlan.conf
+    touch /tmp/dnsmasq.wlan.conf
     /etc/init.d/dnsmasq stop
     killall hostapd
     sleep 1;
-    pidof hostapd && (kill -9 `pidof hostapd` || exit 100)
-    pidof dnsmasq && (kill -9 `pidof dnsmasq` || exit 100)
-    /etc/init.d/dnsmasq start || exit 100
+    pidof hostapd && (kill -9 `pidof hostapd` || exit 127)
+    pidof dnsmasq && (kill -9 `pidof dnsmasq` || exit 127)
+    /etc/init.d/dnsmasq start || exit 127
+    exit 0 ;;
+
+  WIFIAP_WLAN_UP)
+    echo "WIFIAP_WLAN_UP"
+    AP_IP=$2
+    /sbin/ifconfig | grep ${IFACE} || exit 127
+    /sbin/ifconfig ${IFACE} ${AP_IP} up || exit 127
+    exit 0 ;;
+
+  DNSMASQ_RESTART)
+    echo "interface=${IFACE}" >> /tmp/dnsmasq.wlan.conf
+    /etc/init.d/dnsmasq stop
+    pkill -9 dnsmasq
+    /etc/init.d/dnsmasq start || exit 127
     exit 0 ;;
 
   WIFICLIENT_START_SCAN)
     echo "WIFICLIENT_START_SCAN"
-    (/usr/sbin/iw dev wlan0 scan | grep 'BSS\|SSID\|signal') || exit 96
+    (/usr/sbin/iw dev ${IFACE} scan | grep 'BSS\|SSID\|signal') || exit 127
     exit 0 ;;
 
+  WIFICLIENT_CONNECT)
+    echo "WIFICLIENT_CONNECT"
+    WPA_CFG=$2
+    [ -f ${WPA_CFG} ] || exit 127
+    # wpa_supplicant is running, return duplicated request
+    /bin/ps -A | grep wpa_supplicant && exit 14
+    /sbin/wpa_supplicant -d -Dnl80211 -c ${WPA_CFG} -i${IFACE} -B || exit 127
+    CheckConnection ${IFACE} ;;
+
   WIFICLIENT_DISCONNECT)
     echo "WIFICLIENT_DISCONNECT"
-    /sbin/wpa_cli -i${IFACE} terminate || exit 97
+    /sbin/wpa_cli -i${IFACE} terminate || exit 127
     echo "WiFi client disconnected."
     exit 0 ;;
 
-  WIFICLIENT_CONNECT_WPA_PASSPHRASE)
-    PASSPHRASE=$4
-    echo "WIFICLIENT_CONNECT_WPA_PASSPHRASE"
-    /sbin/wpa_passphrase "${SSID}" ${PASSPHRASE} || exit 98
-    echo "ctrl_interface=DIR=/var/run/wpa_supplicant" | tee -a /tmp/${WPA_CFG}
+  IPTABLE_DHCP_INSERT)
+    echo "IPTABLE_DHCP_INSERT"
+    /usr/sbin/iptables -I INPUT -i ${IFACE} -p udp -m udp \
+     --sport 67:68 --dport 67:68 -j ACCEPT  || exit 127
     exit 0 ;;
 
-  WIFICLIENT_CONNECT_SECURITY_NONE)
-    echo "WIFICLIENT_CONNECT_SECURITY_NONE mode"
-    HIDDENAP=$4
-    # Run wpa_supplicant daemon
-    /sbin/wpa_supplicant -d -Dnl80211 -c /etc/${WPA_CFG} -i${IFACE} -B || exit 99
-
-    /sbin/wpa_cli -i${IFACE} disconnect
-    for i in `/sbin/wpa_cli -i${IFACE} list_networks | grep ^[0-9] | cut -f1`; do
-        /sbin/wpa_cli -i${IFACE} remove_network $i
-    done
-    (/sbin/wpa_cli -i${IFACE} add_network | grep 0) || exit 1
-    (/sbin/wpa_cli -i${IFACE} set_network 0 auth_alg OPEN | grep OK) || exit 2
-    (/sbin/wpa_cli -i${IFACE} set_network 0 key_mgmt NONE | grep OK) || exit 3
-    (/sbin/wpa_cli -i${IFACE} set_network 0 mode 0 | grep OK) || exit 4
-    (/sbin/wpa_cli -i${IFACE} set_network 0 ssid \"${SSID}\" | grep OK) || exit 5
-    (/sbin/wpa_cli -i${IFACE} set_network 0 scan_ssid $HIDDENAP | grep OK) || exit 9
-    (/sbin/wpa_cli -i${IFACE} select_network 0 | grep OK) || exit 6
-    (/sbin/wpa_cli -i${IFACE} enable_network 0 | grep OK) || exit 7
-    (/sbin/wpa_cli -i${IFACE} reassociate | grep OK) || exit 8
-    /sbin/wpa_cli -i${IFACE} status
-
-    CheckConnection ${IFACE} ;;
-
-  WIFICLIENT_CONNECT_SECURITY_WEP)
-    echo "WIFICLIENT_CONNECT_SECURITY_WEP mode"
-    HIDDENAP=$4
-    WEPKEY=$5
-    # Run wpa_supplicant daemon
-    /sbin/wpa_supplicant -d -Dnl80211 -c /etc/${WPA_CFG} -i${IFACE} -B || exit 99
-
-    /sbin/wpa_cli -i${IFACE} disconnect
-    for i in `/sbin/wpa_cli -i${IFACE} list_networks | grep ^[0-9] | cut -f1`; do
-        /sbin/wpa_cli -i${IFACE} remove_network $i
-    done
-    (/sbin/wpa_cli -i${IFACE} add_network | grep 0) || exit 1
-    (/sbin/wpa_cli -i${IFACE} set_network 0 auth_alg OPEN | grep OK) || exit 2
-    (/sbin/wpa_cli -i${IFACE} set_network 0 wep_key0 \"${WEPKEY}\" | grep OK) || exit 3
-    (/sbin/wpa_cli -i${IFACE} set_network 0 key_mgmt NONE | grep OK) || exit 4
-    (/sbin/wpa_cli -i${IFACE} set_network 0 mode 0 | grep OK) || exit 5
-    (/sbin/wpa_cli -i${IFACE} set_network 0 ssid \"${SSID}\" | grep OK) || exit 6
-    (/sbin/wpa_cli -i${IFACE} set_network 0 scan_ssid $HIDDENAP | grep OK) || exit 10
-    (/sbin/wpa_cli -i${IFACE} select_network 0 | grep OK) || exit 7
-    (/sbin/wpa_cli -i${IFACE} enable_network 0 | grep OK) || exit 8
-    (/sbin/wpa_cli -i${IFACE} reassociate | grep OK) || exit 9
-    /sbin/wpa_cli -i${IFACE} status
-
-    CheckConnection ${IFACE} ;;
-
-  WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL)
-    echo "WIFICLIENT_CONNECT_SECURITY_WPA_PSK_PERSONAL mode"
-    [ -f /tmp/${WPA_CFG} ] || exit 1
-
-    # Run wpa_supplicant daemon
-    (/sbin/wpa_supplicant -d -Dnl80211 -c /tmp/${WPA_CFG} -i${IFACE} -B) || exit 99
-
-    CheckConnection ${IFACE} ;;
-
-  WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL)
-    echo "WIFICLIENT_CONNECT_SECURITY_WPA2_PSK_PERSONAL mode"
-    [ -f /tmp/${WPA_CFG} ] || exit 1
-
-    # Run wpa_supplicant daemon
-    (/sbin/wpa_supplicant -d -Dnl80211 -c /tmp/${WPA_CFG} -i${IFACE} -B) || exit 99
-
-    /sbin/wpa_cli -i${IFACE} status
-
-    CheckConnection ${IFACE} ;;
-
-  WIFICLIENT_CONNECT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE)
-    HIDDENAP=$4
-    ID=$5
-    PASSWD=$6
-    echo "WIFICLIENT_CONNECT_SECURITY_WPA_EAP_PEAP0_ENTERPRISE mode"
-    # Run wpa_supplicant daemon
-    /sbin/wpa_supplicant -d -Dnl80211 -c /etc/${WPA_CFG} -i${IFACE} -B || exit 99
-
-    /sbin/wpa_cli -i${IFACE} disconnect
-    for i in `/sbin/wpa_cli -i${IFACE} list_networks | grep ^[0-9] | cut -f1`; do
-        /sbin/wpa_cli -i${IFACE} remove_network $i
-    done
-    (/sbin/wpa_cli -i${IFACE} add_network | grep 0) || exit 1
-    (/sbin/wpa_cli -i${IFACE} set_network 0 auth_alg OPEN | grep OK) || exit 2
-    (/sbin/wpa_cli -i${IFACE} set_network 0 key_mgmt WPA-EAP | grep OK) || exit 3
-    (/sbin/wpa_cli -i${IFACE} set_network 0 pairwise TKIP | grep OK) || exit 4
-    (/sbin/wpa_cli -i${IFACE} set_network 0 group TKIP | grep OK) || exit 5
-    (/sbin/wpa_cli -i${IFACE} set_network 0 proto WPA | grep OK) || exit 6
-    (/sbin/wpa_cli -i${IFACE} set_network 0 eap PEAP | grep OK) || exit 7
-    (/sbin/wpa_cli -i${IFACE} set_network 0 identity \"${ID}\" | grep OK) || exit 8
-    (/sbin/wpa_cli -i${IFACE} set_network 0 password \"${PASSWD}\" | grep OK) || exit 9
-    (/sbin/wpa_cli -i${IFACE} set_network 0 scan_ssid $HIDDENAP | grep OK) || exit 17
-    (/sbin/wpa_cli -i${IFACE} set_network 0 phase1 \"peapver=0\" | grep OK) || exit 10
-    (/sbin/wpa_cli -i${IFACE} set_network 0 phase2 \"auth=MSCHAPV2\" | grep OK) || exit 11
-    (/sbin/wpa_cli -i${IFACE} set_network 0 mode 0 | grep OK) || exit 12
-    (/sbin/wpa_cli -i${IFACE} set_network 0 ssid \"${SSID}\" | grep OK) || exit 13
-    (/sbin/wpa_cli -i${IFACE} select_network 0 | grep OK) || exit 14
-    (/sbin/wpa_cli -i${IFACE} enable_network 0 | grep OK) || exit 15
-    (/sbin/wpa_cli -i${IFACE} reassociate | grep OK) || exit 16
-    /sbin/wpa_cli -i${IFACE} status
-
-    CheckConnection ${IFACE} ;;
-
-  WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE)
-    HIDDENAP=$4
-    ID=$5
-    PASSWD=$6
-    echo "WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE mode"
-    # Run wpa_supplicant daemon
-    /sbin/wpa_supplicant -d -Dnl80211 -c /etc/${WPA_CFG} -i${IFACE} -B || exit 99
-
-    /sbin/wpa_cli -i${IFACE} disconnect
-    for i in `/sbin/wpa_cli -i${IFACE} list_networks | grep ^[0-9] | cut -f1`; do
-        /sbin/wpa_cli -i${IFACE} remove_network $i
-    done
-    (/sbin/wpa_cli -i${IFACE} add_network | grep 0) || exit 1
-    (/sbin/wpa_cli -i${IFACE} set_network 0 auth_alg OPEN | grep OK) || exit 2
-    (/sbin/wpa_cli -i${IFACE} set_network 0 key_mgmt WPA-EAP | grep OK) || exit 3
-    (/sbin/wpa_cli -i${IFACE} set_network 0 pairwise CCMP | grep OK) || exit 4
-    (/sbin/wpa_cli -i${IFACE} set_network 0 group CCMP | grep OK) || exit 5
-    (/sbin/wpa_cli -i${IFACE} set_network 0 proto WPA2 | grep OK) || exit 6
-    (/sbin/wpa_cli -i${IFACE} set_network 0 eap PEAP | grep OK) || exit 7
-    (/sbin/wpa_cli -i${IFACE} set_network 0 identity \"${ID}\" | grep OK) || exit 8
-    (/sbin/wpa_cli -i${IFACE} set_network 0 password \"${PASSWD}\" | grep OK) || exit 9
-    (/sbin/wpa_cli -i${IFACE} set_network 0 phase1 \"peapver=0\" | grep OK) || exit 10
-    (/sbin/wpa_cli -i${IFACE} set_network 0 phase2 \"auth=MSCHAPV2\" | grep OK) || exit 11
-    (/sbin/wpa_cli -i${IFACE} set_network 0 mode 0 | grep OK) || exit 12
-    (/sbin/wpa_cli -i${IFACE} set_network 0 ssid \"${SSID}\" | grep OK) || exit 13
-    (/sbin/wpa_cli -i${IFACE} set_network 0 scan_ssid $HIDDENAP | grep OK) || exit 17
-    (/sbin/wpa_cli -i${IFACE} select_network 0 | grep OK) || exit 14
-    (/sbin/wpa_cli -i${IFACE} enable_network 0 | grep OK) || exit 15
-    (/sbin/wpa_cli -i${IFACE} reassociate | grep OK) || exit 16
-    /sbin/wpa_cli -i${IFACE} status
-
-    CheckConnection ${IFACE} ;;
+  IPTABLE_DHCP_DELETE)
+    echo "IPTABLE_DHCP_DELETE"
+    /usr/sbin/iptables -D INPUT -i ${IFACE} -p udp -m udp \
+     --sport 67:68 --dport 67:68 -j ACCEPT  || exit 127
+    exit 0 ;;
 
   *)
     echo "Parameter not valid"
-    exit 99 ;;
+    exit 127 ;;
 esac
 
diff --git a/service/platformAdaptor/ti_simu/pa_wifi_ap_ti.c b/service/platformAdaptor/ti_simu/pa_wifi_ap_ti.c
index 7d7ec6f..bc813c6 100644
--- a/service/platformAdaptor/ti_simu/pa_wifi_ap_ti.c
+++ b/service/platformAdaptor/ti_simu/pa_wifi_ap_ti.c
@@ -44,7 +44,7 @@ static bool     SavedDiscoverable  = true;
  * The WiFi channel associated with the SSID
  */
 //--------------------------------------------------------------------------------------------------
-static uint32_t SavedChannelNumber = 0;
+static uint16_t SavedChannelNumber = 0;
 //--------------------------------------------------------------------------------------------------
 /**
  * The maximum numbers of clients the AP is able to manage
@@ -558,7 +558,7 @@ le_result_t pa_wifiAp_SetDiscoverable
 //--------------------------------------------------------------------------------------------------
 le_result_t pa_wifiAp_SetChannel
 (
-    int8_t channelNumber
+    uint16_t channelNumber
         ///< [IN]
         ///< the channel number must be between 1 and 14.
 )
diff --git a/service/platformAdaptor/ti_simu/pa_wifi_client_ti.c b/service/platformAdaptor/ti_simu/pa_wifi_client_ti.c
index 3fb3b84..09e1847 100644
--- a/service/platformAdaptor/ti_simu/pa_wifi_client_ti.c
+++ b/service/platformAdaptor/ti_simu/pa_wifi_client_ti.c
@@ -131,7 +131,8 @@ static le_thread_Ref_t WifiClientPaThread = NULL;
 
 //--------------------------------------------------------------------------------------------------
 /**
- * WifiClient state event ID used to report WifiClient state events to the registered event handlers.
+ * WifiClient state event ID used to report WifiClient state events to the registered event
+ * handlers.
  */
 //--------------------------------------------------------------------------------------------------
 static le_event_Id_t WifiClientPaEvent;
@@ -486,7 +487,7 @@ le_result_t pa_wifiClient_GetScanResult
     }
 
     /* Default values */
-    accessPointPtr->signalStrength = 0xffff;
+    accessPointPtr->signalStrength = LE_WIFICLIENT_NO_SIGNAL_STRENGTH;
     accessPointPtr->ssidLength = 0;
 
     /* Read the output a line at a time - output it. */
@@ -894,13 +895,13 @@ le_result_t pa_wifiClient_Connect
             {
                 LE_INFO("Step 2: SH script");
                 snprintf(tmpString,
-                    sizeof(tmpString),
-                    (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE),
-                    ssidLength,
-                    (char *)ssidBytes,
-                    HiddenAccessPoint,
-                    SavedUsername,
-                    SavedPassword);
+                   sizeof(tmpString),
+                   (WIFI_SCRIPT_PATH COMMAND_WIFICLIENT_CONNECT_SECURITY_WPA2_EAP_PEAP0_ENTERPRISE),
+                   ssidLength,
+                   (char *)ssidBytes,
+                   HiddenAccessPoint,
+                   SavedUsername,
+                   SavedPassword);
 
                 systemResult = system(tmpString);
                 // Return value of -1 means that the fork() has failed (see man system).
diff --git a/service/wifiService.adef b/service/wifiService.adef
index 9aa6848..b179d08 100644
--- a/service/wifiService.adef
+++ b/service/wifiService.adef
@@ -34,3 +34,8 @@ extern:
     wifiService.daemon.le_wifiAp
     wifiService.daemon.le_wifiClient
 }
+
+bindings:
+{
+    wifiService.daemon.le_secStore -> <root>.le_secStore
+}
diff --git a/wifi.sdef b/wifi.sdef
index 89e56b7..3646a05 100644
--- a/wifi.sdef
+++ b/wifi.sdef
@@ -6,20 +6,20 @@
 //--------------------------------------------------------------------------------------------------
 
 #include "$LEGATO_ROOT/default.sdef"
+// #include "wifi.sinc"
+// #include "wifi_samples.sinc"
 
 buildVars:
 {
     LEGATO_WIFI_ROOT=${LEGATO_ROOT}/modules/WiFi
-    LEGATO_WIFI_PA=ti
+    // File is selected by users, replace "ti" with "qca" to support qca chipset
+    LEGATO_WIFI_PA=${LEGATO_WIFI_ROOT}/service/platformAdaptor/ti/pa_wifi.sh
 }
 
 apps:
 {
     // WiFi services
     $LEGATO_WIFI_ROOT/service/wifiService.adef
-    $LEGATO_WIFI_ROOT/apps/sample/wifiClientTest/wifiClientTest.adef
-    $LEGATO_WIFI_ROOT/apps/sample/wifiApTest/wifiApTest.adef
-    $LEGATO_WIFI_ROOT/apps/sample/wifiWebAp/wifiWebAp.adef
     $LEGATO_WIFI_ROOT/apps/tools/wifi/wifi.adef
 }
 
diff --git a/wifi.sinc b/wifi.sinc
new file mode 100644
index 0000000..39584f3
--- /dev/null
+++ b/wifi.sinc
@@ -0,0 +1,24 @@
+//--------------------------------------------------------------------------------------------------
+// Legato WiFi support
+//
+// Copyright (C) Sierra Wireless Inc.
+//--------------------------------------------------------------------------------------------------
+
+buildVars:
+{
+    LEGATO_WIFI_ROOT=${LEGATO_ROOT}/modules/WiFi
+    // File is selected by users, replace "ti" with "qca" to support qca chipset
+    LEGATO_WIFI_PA=${LEGATO_WIFI_ROOT}/service/platformAdaptor/ti/pa_wifi.sh
+}
+
+apps:
+{
+    // WiFi services
+    $LEGATO_WIFI_ROOT/service/wifiService.adef
+    $LEGATO_WIFI_ROOT/apps/tools/wifi/wifi.adef
+}
+
+commands:
+{
+    wifi = wifi:/bin/wifi
+}
diff --git a/wifi_samples.sinc b/wifi_samples.sinc
new file mode 100644
index 0000000..d489850
--- /dev/null
+++ b/wifi_samples.sinc
@@ -0,0 +1,12 @@
+//--------------------------------------------------------------------------------------------------
+// Legato WiFi sample applications
+//
+// Copyright (C) Sierra Wireless Inc.
+//--------------------------------------------------------------------------------------------------
+
+apps:
+{
+    $LEGATO_WIFI_ROOT/apps/sample/wifiClientTest/wifiClientTest.adef
+    $LEGATO_WIFI_ROOT/apps/sample/wifiApTest/wifiApTest.adef
+    $LEGATO_WIFI_ROOT/apps/sample/wifiWebAp/wifiWebAp.adef
+}
\ No newline at end of file
